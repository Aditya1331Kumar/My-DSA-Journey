# easy hai !!!


```java
System.arraycopy(nums, 0, result, 0, nums.length);
```

`System.arraycopy(src, srcPos, dest, destPos, length)` parameters:

* `src = nums` (source array)
* `srcPos = 0` (start copying from index 0 of `nums`)
* `dest = result` (destination array)
* `destPos = 0` (start writing at index 0 of `result`)
* `length = nums.length` (number of elements to copy, i.e., `n`)

Effect after this call:

* `result[0]` gets `nums[0]`, `result[1]` gets `nums[1]`, …, `result[n-1]` gets `nums[n-1]`.

Example: if `nums = [1,2,3]` (n=3), after first copy:
`result` becomes `[1, 2, 3, 0, 0, 0]`.

`System.arraycopy` is implemented natively and is very fast (memmove-like), performing a block copy of primitive values.

---

### 4) Second copy — place `nums` into the second half of `result`

```java
System.arraycopy(nums, 0, result, nums.length, nums.length);
```

Parameters:

* `src = nums`
* `srcPos = 0`
* `dest = result`
* `destPos = nums.length` (start writing at index `n` — the second half)
* `length = nums.length` (copy `n` elements)

Effect after this call:

* `result[n]` gets `nums[0]`, `result[n+1]` gets `nums[1]`, …, `result[2n-1]` gets `nums[n-1]`.

Continuing the example (`nums = [1,2,3]`): after second copy:
`result` becomes `[1, 2, 3, 1, 2, 3]`.

This achieves the concatenation: `result = nums + nums`.

---

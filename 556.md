# leetcode problem 556

***8***
---
*** *** 
---

## some important points to leran:

---
 # Achha Soln:
```java
class Solution {
    public int nextGreaterElement(int n) {
        char[] digits = Integer.toString(n).toCharArray();

        // Step 1: Find the first decreasing digit from right
        int i = digits.length - 2;
        while (i >= 0 && digits[i] >= digits[i + 1]) {
            i--;
        }

        // If no such index, then no larger permutation is possible
        if (i < 0) return -1;

        // Step 2: Find the next greater digit to the right of i and swap
        int j = digits.length - 1;
        while (digits[j] <= digits[i]) {
            j--;
        }

        // Swap digits[i] and digits[j]
        char temp = digits[i];
        digits[i] = digits[j];
        digits[j] = temp;

        // Step 3: Reverse the portion after i to get the smallest number
        reverse(digits, i + 1, digits.length - 1);

        // Step 4: Convert to integer and handle overflow
        try {
            int result = Integer.parseInt(new String(digits));
            return result;
        } catch (NumberFormatException e) {
            return -1; // Overflow case
        }
    }

    private void reverse(char[] arr, int left, int right) {
        while (left < right) {
            char temp = arr[left];
            arr[left++] = arr[right];
            arr[right--] = temp;
        }
    }
}


```
---
---
 # The my Fav soln
```java
// Goal: n ke digits se exactly same digits use karke next greater number banana. Agar possible nahi, ya > 2,147,483,647 ho gaya, to -1.
class Solution {
    public int nextGreaterElement(int n) {
        char[] d = String.valueOf(n).toCharArray();
// Number ko string, phir char array bana diya: e.g. 12431 -> ['1','2','4','3','1']. Char array pe in-place swap/reverse karna easy ho jata ha
        // 1) Find pivot
        int i = d.length - 2;
        while (i >= 0 && d[i] >= d[i + 1]) i--;
        if (i < 0) return -1; // no next permutation

        // 2) Find the smallest digit > d[i] on the right side
        int j = d.length - 1;
        while (j > i && d[j] <= d[i]) j--;

        // 3) Swap pivot with that digit
        char tmp = d[i];
        d[i] = d[j];
        d[j] = tmp;

        // 4) Reverse the suffix to make it smallest
        int l = i + 1, r = d.length - 1;
        while (l < r) {
            char t = d[l];
            d[l] = d[r];
            d[r] = t;
            l++; r--;
        }

        // 5) Build number & overflow check
        long val = Long.parseLong(new String(d));
        return (val <= Integer.MAX_VALUE) ? (int) val : -1;
    }
}


```
---
---
 # Maine kaise socha


Meri dimaag ki language me:
ðŸ‘‰ **"Find the next permutation of digits, but bounded by int range."**



## Identify problem type

* â€œDigits same rakhne hainâ€ â†’ matlab permutation.
* â€œNext greater numberâ€ â†’ matlab **lexicographically next permutation**.
* Ye bahut classic problem hai: â€œNext Permutationâ€ (LeetCode 31).


## ðŸ§  Step 3 â€“ Next Permutation algorithm yaad karo



1. Pivot find karo jahan increase possible ho.
2. Right side me just-bada element se swap karo.
3. Suffix ko reverse karo taaki smallest ban jaaye.



## Why pivot / swap / reverse work karta hai (intuition check)

Mujhe hamesha reasoning chahiye hoti hai (warna code bas ratta ho jaata hai):

* Agar poore digits descending hain â†’ matlab already *largest permutation* â†’ next possible hi nahi.
* Agar kahin left se ek aisa digit hai jo chhota hai apne right wale se â†’ wahin se increment possible hai.
* Increment minimal rakhna hai â†’ us digit ko bas thoda bada bana do (right side ka just-bada number).
* Baaki right side ko ascending me rakho â†’ overall number sabse chhota ban jaayega.

---

## ðŸ§  Step 5 â€“ Edge cases dimaag me check karo

* Single digit â†’ no next greater.
* Already descending (e.g. 4321) â†’ -1.
* Bada banega lekin overflow ho sakta hai (1999999999 â†’ 9199999999) â†’ handle with long.

---

## ðŸ§  Step 6 â€“ Code structure bana

Tab dimaag me skeleton code ban gaya:

```java
char[] d = String.valueOf(n).toCharArray();
find pivot i;
if (no pivot) return -1;
find just-bigger digit j;
swap(i, j);
reverse suffix;
build number, check overflow;
```
---

 # Code walkthrough (line by line + invariants)

```java
char[] d = String.valueOf(n).toCharArray();
```

* Number ko string, phir char array bana diya: e.g. `12431 -> ['1','2','4','3','1']`.
* Char array pe in-place swap/reverse karna easy ho jata hai.

---

## 1) Find pivot

```java
int i = d.length - 2;
while (i >= 0 && d[i] >= d[i + 1]) i--;
if (i < 0) return -1; // no next permutation
```

* `i` ko right se start karte hain (second last index).
* **Loop meaning:** jab tak `d[i] >= d[i+1]`, left move karo.
* Iska result: ya to `i` mil jayega jahan `d[i] < d[i+1]` (isko **pivot** kehte hain),
  ya phir `i` `-1` ho jayega (poora array non-increasing/descending hai like `54321`) â†’ **no larger permutation** â†’ `-1`.

**Why pivot exists â‡’ next greater possible?**

* Right side (`i+1..end`) ab **non-increasing** hai (descending).
* Agar pivot mil gaya (`d[i] < d[i+1]`), to `d[i]` ko thoda sa bada karke baaki ko minimal arrange karke next greater ban sakta hai.

---

## 2) Right side me â€œjust badaâ€ element dhoondo

```java
int j = d.length - 1;
while (j > i && d[j] <= d[i]) j--;
```

* Rightmost se left aao, **pehla** element dhoondo jo `d[i]` se **strictly bada** ho.
* Kyon rightmost? Kyunki suffix `i+1..end` descending hai. Rightmost > `d[i]` actually **smallest possible greater** hoga (proof niche).

**Intuition/Proof (short):**
Suffix descending: e.g. `[9,7,6,4]`. `d[i]=4` se just bada rightmost se milega `6` (not `9`), because descending order me **pehla jo milta hai** woh hi **smallest greater** hota hai. Isse increment minimal rehta hai â†’ next number minimal greater hota hai.

---

## 3) Swap pivot with that element

```java
char tmp = d[i];
d[i] = d[j];
d[j] = tmp;
```

* Ab prefix `0..i-1` same, `d[i]` thoda bada ho gaya.
* Overall number ab **greater** ho chuka hai; bas isse **as small as possible** banana hai.

---

## 4) Suffix ko reverse (ascending) kar do

```java
int l = i + 1, r = d.length - 1;
while (l < r) {
    char t = d[l]; d[l] = d[r]; d[r] = t;
    l++; r--;
}
```

* Pivot ke baad jo suffix (`i+1..end`) tha, swap se pehle **descending** tha; swap ke baad bhi woh **almost descending** hi hota hai.
* Next greater number ko **minimum** rakhne ke liye suffix ko **ascending** chahiye.
* Descending ko ascending banane ka sabse fast tareeqa: **reverse** (O(k)).

  * Example: `[9,7,6,1]` â†’ reverse â†’ `[1,6,7,9]` (ascending).

**Why ascending suffix = globally smallest after the new prefix?**

* Kyunki prefix fixed ho chuka (swap ke baad), aur minimal total banane ke liye right side smallest lexicographic order chahiye â†’ ascending.

---

## 5) Build number & overflow check

```java
long val = Long.parseLong(new String(d));
return (val <= Integer.MAX_VALUE) ? (int) val : -1;
```

* `long` me parse: safe.
* Agar `> 2,147,483,647` ho gaya to **-1** (LeetCode constraint).

---

# Dry runs (step-by-step)

### Example A: `n = 12431`

* `d = [1,2,4,3,1]`
* Pivot search:

  * Compare pairs from right: `3>1` (ok), `4>3` (ok), but `2<4` â†’ `i = 1` (pivot = `2`)
* Find `j`: rightmost `> 2` in `[4,3,1]` â‡’ `3` at index 3
* Swap `i` & `j`: `[1,3,4,2,1]`
* Reverse suffix (`i+1..end`): `[4,2,1]` â†’ `[1,2,4]`
  Final: **`13124`**

### Example B: `n = 218765`

* `d = [2,1,8,7,6,5]`
* Pivot: from right `7>6`, `8>7`, but `1<8` â‡’ `i=1` (pivot = `1`)
* `j`: rightmost `> 1` in `[8,7,6,5]` â‡’ `5`
* Swap: `[2,5,8,7,6,1]`
* Reverse suffix: `[8,7,6,1]` â†’ `[1,6,7,8]`
  Final: **`251678`**

### Example C: `n = 21`

* `d = [2,1]` is already descending; pivot not found â‡’ return **`-1`**

### Example D: overflow check (`n = 1999999999`)

* Pivot exists: swap etc. result banega `9199999999` (clearly `> 2,147,483,647`)
* `val` long me bada nikla â‡’ return **`-1`**

---


# Complexity

* Pivot search: O(k),
* `j` search: O(k),
* Reverse: O(k).
  Total: **O(k)** time, **O(1)** extra space (char array in place).


---
 # Another soln
```java
ye alter soln h kya same method h 
step by step dteail mein samjhao
class Solution {
    public int nextGreaterElement(int n) {
        ArrayList<Integer>a=new ArrayList<>();
        while(n>0){
             int r=n%10;
             a.add(r);
             n/=10;
        }
        Collections.reverse(a);
        int lastIndex=-1;
        int maxIndex=-1;
        boolean b=true;
        for(int i=a.size()-1;i>=1;i--){
            if(a.get(i)>a.get(i-1)){
                lastIndex=i-1;
                b=false;
                break;
            }
        }
        if(b){
            return lastIndex;
        }
        for(int i=a.size()-1;i>=0;i--){
            if(a.get(i)>a.get(lastIndex)){
                maxIndex=i;
                break;
            }
        }
        int temp=a.get(lastIndex);
        a.set(lastIndex,a.get(maxIndex));
        a.set(maxIndex,temp);
        Collections.sort(a.subList(lastIndex+1,a.size()));
        // Performance note: Collections.sort is O(k log k) while reversing is O(k); for up to 10 digits both are trivial, but reverse is the optimal trick.
        long sum=0;
        for(int i=0;i<a.size();i++){
            sum=(sum*10+a.get(i));
        }
        if(sum>Integer.MAX_VALUE){
            return -1;
        }
        return (int)sum;     
    }
}

```
---
---
 # Another code
```java
class Solution {
    public int nextGreaterElement(int n) {
        char[] num = ("" + n).toCharArray();
        // n ko string me convert karke char[] banaya 
        // num[0] = most significant digit, num[num.length-1] = least significant.
        int i, j;
        for(i = num.length - 1; i > 0; i--){
            if(num[i-1] < num[i]) break;
        }
        if(i == 0) return -1;
        int x = num[i - 1], smallest = i;
        // x holds the pivot value (num[p]). smallest initialized to i (first index of suffix).
        for(j = i + 1; j < num.length; j++){
            if(num[j] > x && num[j] <= num[smallest]) smallest = j;
        }
        char temp = num[i - 1];
        num[i - 1] = num[smallest];
        num[smallest] = temp;

        Arrays.sort(num, i, num.length);

        long val = Long.parseLong(new String(num));
        return (val <= Integer.MAX_VALUE) ? (int)val : -1;
    }
}


```
---
---
 #
```java


```
---
---
 #
```java


```
---
---
 #
```java


```
---
---
 #
```java


```
---
---
 #
```java


```
---
---
 #
```java


```
---
---
 #
```java


```
---
---
 #
```java


```
---
---
 #
```java


```
---
---
 #
```java


```
---
---
 #
```java


```
---
---
 #
```java


```
---
---
 #
```java


```
---
---
 #
```java


```
---
---
 #
```java


```
---
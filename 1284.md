# leetcode problem 

***8***
---
*** *** 
---

## some important points to leran:

---
 # jaruri hai 
```java
int x = 1;
x = x ^ 1;   // 1 ban jayega 0, aur 0 ban jayega 1


```
---
---
 # mera soln jo pura galat nahi h 
```java
class Solution {
    public int minFlips(int[][] mat) {
return recur ( mat  , 0,0);
        
    }
    public void flip (int[][] mat  , int row , int col) {
       mat[row][col]= mat[row][col] ^ 1;  
       mat[row-1][col]= mat[row-1][col] ^ 1;  
       mat[row+1][col]= mat[row+1][col] ^ 1;  
       mat[row][col+1]= mat[row][col+1] ^ 1;  
       mat[row][col-1]= mat[row][col-1] ^ 1;  
    }
     public boolean recur (int[][] mat  , int row , int col) {
        if(isZeroMatrix( mat)){return true;}
        if(col>=mat[0].length && row>=mat.length) return false ;
       flip(mat[][] ,row,col+1) ;  
       recur ( mat  , row+1 , int col)
       return isZeroMatrix( mat)
    }

    public boolean isZeroMatrix(int[][] matrix) {
        int rows = matrix.length;
        int cols = matrix[0].length;

        for (int i = 0; i < rows; i++) {
            for (int j = 0; j < cols; j++) {
                if (matrix[i][j] != 0) {
                    return false; // Found a non-zero element
                }
            }
        }
        return true; // All elements are zero
    }
}


```


## usi ka correct version of 1 ms runtime
```java
class Solution {
    int m, n;
    int INF = 100; // bada number (kyunki max 3x3 hi hai)

    public int minFlips(int[][] mat) {
        m = mat.length;
        n = mat[0].length;
        int ans = dfs(mat, 0, 0);
        return ans >= INF ? -1 : ans;
    }

    // Recursive function
    private int dfs(int[][] mat, int row, int col) {
        // âœ… Base case: agar matrix zero ban gayi
        if (isZeroMatrix(mat)) return 0;

        // âœ… Agar sab cells traverse kar liye aur zero matrix nahi bani
        if (row == m) return INF;

        // Next row/col calculate karo
        int nextRow = col == n - 1 ? row + 1 : row;
        int nextCol = col == n - 1 ? 0 : col + 1;

        // Choice 1: iss cell ko flip NA karo
        int notFlip = dfs(mat, nextRow, nextCol);

        // Choice 2: iss cell ko flip karo
        flip(mat, row, col);
        int flipAns = 1 + dfs(mat, nextRow, nextCol);
        flip(mat, row, col); // ðŸ”´ IMPORTANT: backtrack

        // Minimum answer return karo
        return Math.min(notFlip, flipAns);
    }

    // Flip function with boundary check
    private void flip(int[][] mat, int r, int c) {
        int[][] dirs = {{0,0},{1,0},{-1,0},{0,1},{0,-1}};
        for (int[] d : dirs) {
            int nr = r + d[0];
            int nc = c + d[1];
            if (nr >= 0 && nr < m && nc >= 0 && nc < n) {
                mat[nr][nc] ^= 1; // toggle 0<->1
            }
        }
    }

    // Check zero matrix
    private boolean isZeroMatrix(int[][] mat) {
        for (int[] row : mat) {
            for (int val : row) {
                if (val != 0) return false;
            }
        }
        return true;
    }
}
```
---
---
 # Queue and linklist  ka use kar 
```java
class Solution {
    public int minFlips(int[][] mat) {
        int m = mat.length, n = mat[0].length;
        
        // Convert matrix -> bitmask
        int start = 0;
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (mat[i][j] == 1) {
                    start |= (1 << (i * n + j));
                }
            }
        }

        // If already all zero
        if (start == 0) return 0;

        Queue<Integer> q = new LinkedList<>();
        Set<Integer> visited = new HashSet<>();
        
        q.add(start);
        visited.add(start);
        
        int steps = 0;

        // BFS
        while (!q.isEmpty()) {
            int size = q.size();
            steps++;
            for (int k = 0; k < size; k++) {
                int state = q.poll();

                // Try flipping every cell
                for (int i = 0; i < m; i++) {
                    for (int j = 0; j < n; j++) {
                        int next = flip(state, i, j, m, n);
                        if (next == 0) return steps; // All zero
                        if (!visited.contains(next)) {
                            visited.add(next);
                            q.add(next);
                        }
                    }
                }
            }
        }
        return -1; // Impossible
    }

    // Flip (i,j) and its neighbors
    private int flip(int state, int i, int j, int m, int n) {
        int[] dirs = {0, 1, 0, -1, 0};
        for (int d = 0; d < 4; d++) {
            int ni = i + dirs[d], nj = j + dirs[d+1];
            if (ni >= 0 && nj >= 0 && ni < m && nj < n) {
                state ^= (1 << (ni * n + nj));
            }
        }
        // flip itself
        state ^= (1 << (i * n + j));
        return state;
    }
}







```
---
---
 # sabse jyada optimised
```java
class Solution {
    int n,m;
    public int minFlips(int[][] mat) {
        n=mat.length;m=mat[0].length;
        int ans=sol(mat,0,0,0);
        return ans==Integer.MAX_VALUE?-1:ans;
    }
    public int sol(int[][] mat,int i,int j,int c){
        if(j==m){
            j=0;
            i++;
        }
        if(i==n){
            return isValid(mat)?c:Integer.MAX_VALUE;
        }
        int x=sol(mat,i,j+1,c);
        flip(mat,i,j);
        int y=sol(mat,i,j+1,c+1);
        flip(mat,i,j);
        return Math.min(x,y);
    }
    public boolean isValid(int[][] mat){
        for(int i=0;i<n;i++){
            for(int j=0;j<m;j++){
                if(mat[i][j]==1) return false;
            }
        }
        return true;
    }
    public void flip(int[][] mat,int i,int j){
        mat[i][j]^=1;
        if(i>0) mat[i-1][j]^=1;
        if(i<n-1) mat[i+1][j]^=1;
        if(j>0) mat[i][j-1]^=1;
        if(j<m-1) mat[i][j+1]^=1;
    }
}

```
---
---
 #
```java


```
---
---
 #
```java


```
---
---
 #
```java


```
---
---
 #
```java


```
---
---
 #
```java


```
---
---
 #
```java


```
---
---
 #
```java


```
---
---
 #
```java


```
---
---
 #
```java


```
---
---
 #
```java


```
---
---
 #
```java


```
---
---
 #
```java


```
---
---
 #
```java


```
---
---
 #
```java


```
---
---
 #
```java


```
---
---
 #
```java


```
---
---
 #
```java


```
---
# leetcode problem 15

***medium wala h achha h tle kaise hataye ye achha h***
---
*** *** 
---

## some important points to leran:

---
```
1. 
        List<List<Integer>> ans = new ArrayList<>();
                     List<Integer> dol = new ArrayList<>();
dol.add(nums[i]);
dol.add(nums[j]);
dol.add(nums[k]);
if (ans.contains(dol)==false){
ans.add(dol);}
                
```
---
---

2. int k = Arrays.binarySearch(array, fromIndex, toIndex, key)

```

If element is found → returns index (≥ 0).

If not found → returns -(insertion_point) - 1 (negative).
```
---
---
```
3. List.contains() on List<List<Integer>> will check equality, good when array is sorted
 and is O(n) each time → very slow.
```
---
---

4. hash map se solution 
```
class Solution {
    public List<List<Integer>> threeSum(int[] nums) {
        Set<List<Integer>> ans = new HashSet<>();
        Arrays.sort(nums);

        for (int i = 0; i < nums.length; i++) {
            for (int j = i + 1; j < nums.length; j++) {

                int k = Arrays.binarySearch(nums, j + 1, nums.length, -nums[i] - nums[j]);

                if (k >= 0) { // found
                    List<Integer> triplet = Arrays.asList(nums[i], nums[j], nums[k]);
                    ans.add(triplet); // set removes duplicates automatically
                }
            }
        }
        return new ArrayList<>(ans);
    }
}

```
---
---

5. using linklist 
```
class Solution {
    public List<List<Integer>> threeSum(int[] nums) {
        List<List<Integer>> res = new LinkedList<>();
        if (nums.length < 3) return res;
        Arrays.sort(nums);
        // System.out.println(Arrays.toString(nums));

        int i = 0;
        while (i < nums.length) {
            if (nums[i] > 0) break;
            int left = i + 1;
            int right = nums.length - 1;
            int target = -nums[i];
            while (left < right) {
                int sum = nums[left] + nums[right];
                if (sum == target) {
                    res.add(Arrays.asList(nums[i], nums[left], nums[right]));
                    int currLeft = nums[left];
                    while (left < right && nums[left] == currLeft) left ++;
                }
                while  (left < right && sum < target) {
                    left ++;
                    sum = nums[left] + nums[right];
                }
                while (left < right && sum > target) {
                    right --;
                    sum = nums[left] + nums[right];
                }
            }
            int curr = nums[i];
            while (i < nums.length && nums[i] == curr) i ++;
        }

        return res;
    }
}
```
---
---

6. best approch

- Sort the array (increasing).

- Ek index i fix karo (ye triplet ka pehla number hoga).

    - Baaki do numbers ke liye two pointers lagao:

    - left = i+1, right = n-1

    -  sum = nums[i] + nums[left] + nums[right]

     -  Agar sum == 0 → answer me add karo, aur duplicates skip karke pointers move karo.
```
Agar sum < 0 → sum badhane ke liye left++.

Agar sum > 0 → sum ghataane ke liye right--.

i ko aage badhao, duplicate i skip karo.
```


 ye raha solution :
```
import java.util.*;

class Solution {
    public List<List<Integer>> threeSum(int[] nums) {
        List<List<Integer>> res = new ArrayList<>();
        Arrays.sort(nums);
        int n = nums.length;

        for (int i = 0; i < n - 2; i++) {
            // Skip duplicate numbers for i
            if (i > 0 && nums[i] == nums[i - 1]) continue;

            // Early stopping: if smallest sum > 0, break
            if (nums[i] + nums[i + 1] + nums[i + 2] > 0) break;

            // Early skip: if largest sum < 0, move to next i
            if (nums[i] + nums[n - 1] + nums[n - 2] < 0) continue;

            int left = i + 1, right = n - 1;

            while (left < right) {
                int sum = nums[i] + nums[left] + nums[right];

                if (sum == 0) {
                    res.add(Arrays.asList(nums[i], nums[left], nums[right]));
                    left++;
                    right--;

                    // Skip duplicates on left
                    while (left < right && nums[left] == nums[left - 1]) left++;
                    // Skip duplicates on right
                    while (left < right && nums[right] == nums[right + 1]) right--;
                } 
                else if (sum < 0) {
                    left++;
                } 
                else {
                    right--;
                }
            }
        }
        return res;
    }
}

```

Do powerful optimizations
Early break:
```
Sorted array me agar nums[i] + nums[i+1] + nums[i+2] > 0 hua, to aage wale sab sums aur bade honge ⇒ break (koi aur 0-sum nahi ban sakta).
```
```
Early continue:
Agar nums[i] + nums[n-2] + nums[n-1] < 0 hua, to even largest remaining pair ke saath bhi 0 nahi banega ⇒ continue (next i try karo).
```
---
---

7. kuch imp wali bate for above ones
```
Duplicate i: agar nums[i] == nums[i-1] to same first number se banne wale triplets
```
```
Special case: [0,0,0,0] → sirf ek [0,0,0] aayega, kyunki dup-skip kar rahe ho.
```
---
---

8. AbstractList ka use — Lazy result creation
```
import java.util.AbstractList;
class Solution {
 public List<List<Integer>> threeSum(int[] arr) {
		return new AbstractList<List<Integer>>() {
			List<List<Integer>> ans;
			@Override
			public int size() {
				if (ans == null) ans = createList(arr);
				return ans.size();
			}
			@Override
			public List<Integer> get(int index) {
				if (ans == null) ans = createList(arr);
				return ans.get(index);
			}
		};
	}
	private List<List<Integer>> createList(int[] arr) {
		List<List<Integer>> ans = new ArrayList<>();
		int len = arr.length;
		Arrays.sort(arr);
		for (int i = 0; i < len - 2 && arr[i] <= 0; ++i) {
			if (i != 0 && arr[i - 1] == arr[i]) continue;
			twoSum(ans, arr, i + 1, len - 1, -arr[i]);
		}
		return ans;
	}
	private void twoSum(List<List<Integer>> ans, int[] arr, int left, int right, int target) {
		while (left < right) {
			int sum = arr[left] + arr[right];
			if (sum < target) {
				++left;
				continue;
			}
			if (sum > target) {
				--right;
				continue;
			}
			ans.add(Arrays.asList(-target, arr[left++], arr[right--]));
			while (left <= right && arr[left - 1] == arr[left]) ++left;
		}
	}
}
```
---

---
```
9.
```
---
---
```
10.
```
---

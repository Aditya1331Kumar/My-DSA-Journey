# leetcode problem 509

****fibonaci calculate yaar**
---
*** *** 
---

## some important points to leran:

---
 # most khatarnak
```java
class Solution {
    public int fib(int n) {
        if(n==0 || n==1) return n;
        int[] dp = new int[n+1];
        dp[0]=0; dp[1]= 1;
        for(int i=2; i<=n; i++){
            dp[i]=dp[i-1]+dp[i-2];
        }
        return dp[n];
    }
}

```
---
---
 # same same but different
```java
int[] memo = new int[n+1];
Arrays.fill(memo, -1);

int fib(int n){
    if(n < 2) return n;
    if(memo[n] != -1) return memo[n];
    memo[n] = fib(n-1) + fib(n-2);
    return memo[n];
}


```
---
---
 # 3 solutions:

### 1Ô∏è‚É£ Recursion with simple base case & safe termination

```java
class Solution {
    public boolean isPowerOfThree(int n) {
        // base case
        if (n < 1) return false; // negative or zero
        if (n == 1) return true; // 3^0 = 1

        // divisible check
        if (n % 3 != 0) return false;

        // recursive call
        return isPowerOfThree(n / 3);
    }
}
```

‚úÖ Features:

* **Simple & clean**
* **No extra dp array required**
* **Stack overflow safe** for reasonable `n` (max 32-bit integer ‚Üí log3(2^31) ‚âà 20 recursion depth)

---

### 2Ô∏è‚É£ Recursion + Memoization (if huge `n`)

```java
class Solution {
    private Map<Integer, Boolean> memo = new HashMap<>();

    public boolean isPowerOfThree(int n) {
        if (n < 1) return false;
        if (n == 1) return true;

        if (memo.containsKey(n)) return memo.get(n);
        if (n % 3 != 0) {
            memo.put(n, false);
            return false;
        }

        boolean res = isPowerOfThree(n / 3);
        memo.put(n, res);
        return res;
    }
}
```

‚úÖ Features:

* Agar `n` **bahut bada** hai ya **same values baar-baar check ho rahe hain**, memoization speed boost deta hai
* Still safe for large inputs
* `HashMap` use kiya ‚Üí memory ka issue nahi

---

### 3Ô∏è‚É£ Iterative alternative (stack-free, O(log n))

```java
class Solution {
    public boolean isPowerOfThree(int n) {
        if (n < 1) return false;
        while (n % 3 == 0) {
            n /= 3;
        }
        return n == 1;
    }
}
```

‚úÖ Features:

* **No recursion** ‚Üí stack overflow ka risk zero
* O(log n) time
* O(1) space

---

üí° **Tip:**
Recursion tabhi use karo jab:

* Problem naturally divide-and-conquer ho (Fibonacci, DFS, tree traversal)
* Stack depth **limited** ho ya **memoization** ho

Power-of-three jaise simple divisible check problems me **iterative version better** hai.


```java
class Solution {
    public boolean isPowerOfThree(int n) {
        if (n <= 0) return false;
        while (n % 3 == 0) {
            n /= 3;
        }
        return n == 1;
    }
}

```
---
---
 # Alag soln
```java

class Solution {
    public boolean isPowerOfThree(int n) {
        if(n<0) {
            return false;
        }
        int[] dp = new int[31];
        dp[0] = 1;
        if(n == 1) {
            return true;
        }
        for(int i = 1;i<31;i++) {
            if(dp[i-1] * 3 == n) {
                return true;
            } else if(dp[i-1] * 3 > n) {
                return false;
            }
            dp[i] = dp[i-1] * 3;
        }
        return false;
    }
}
```

Bhai, ye code **power of three check karne ka iterative DP-style approach** hai. Chalo step by step detail mein samjhate hain.

---

### 1Ô∏è‚É£ Base case

```java
if(n < 0) {
    return false;
}
```

* Agar `n` negative hai ‚Üí **kabhi bhi 3 ki power nahi ho sakta**
* Isliye direct `false` return

```java
if(n == 1) {
    return true;
}
```

* 3‚Å∞ = 1
* Agar `n` 1 hai ‚Üí power of three hai ‚Üí `true`

---

### 2Ô∏è‚É£ DP array initialization

```java
int[] dp = new int[31];
dp[0] = 1;
```

* `dp[i]` store karega **3^i**
* Maximum size 31 ‚Üí kyunki 3^30 ‚âà 2 √ó 10¬π‚Å¥ (32-bit integer ke limit ke andar)
* `dp[0] = 3‚Å∞ = 1`

---

### 3Ô∏è‚É£ Iterative loop to generate powers of three

```java
for(int i = 1; i < 31; i++) {
    if(dp[i-1] * 3 == n) {
        return true;
    } else if(dp[i-1] * 3 > n) {
        return false;
    }
    dp[i] = dp[i-1] * 3;
}
```

Step by step explanation:

1. **`dp[i-1] * 3 == n`** ‚Üí check karo agar next power of 3 `n` ke barabar hai

   * Agar haan ‚Üí return `true`
2. **`dp[i-1] * 3 > n`** ‚Üí agar next power > n ‚Üí `n` **kabhi 3 ki power nahi ho sakta** ‚Üí return `false`
3. Agar dono nahi ‚Üí `dp[i] = dp[i-1] * 3` ‚Üí next power store karo

---

### 4Ô∏è‚É£ Loop complete hone ke baad

```java
return false;
```

* Agar loop complete ho gaya aur **koi power n ke barabar nahi mila** ‚Üí return `false`

---

### 5Ô∏è‚É£ Example: n = 9

```
dp[0] = 1
i=1: dp[0]*3 = 3 ‚Üí !=9 ‚Üí dp[1]=3
i=2: dp[1]*3 = 9 ‚Üí ==9 ‚Üí return true
```

‚úÖ Correct

---

### 6Ô∏è‚É£ Example: n = 10

```
dp[0] = 1
i=1: dp[0]*3 = 3 ‚Üí !=10 ‚Üí dp[1]=3
i=2: dp[1]*3 = 9 ‚Üí !=10 ‚Üí dp[2]=9
i=3: dp[2]*3 = 27 ‚Üí >10 ‚Üí return false
```

‚úÖ Correct

---

### 7Ô∏è‚É£ Complexity Analysis

* **Time:** O(log‚ÇÉ n) ‚Üí loop runs \~30 times max
* **Space:** O(1) extra space (actually `dp[31]` = constant)

---

### 8Ô∏è‚É£ Summary

1. Base cases check karo ‚Üí `n < 0` false, `n == 1` true
2. Iteratively powers of three generate karo ‚Üí 3‚Å∞, 3¬π, ‚Ä¶
3. Agar koi power `n` ke barabar ‚Üí return true
4. Agar power > n ‚Üí return false

---

‚ö° Note:

* `dp` array actually zaroori nahi hai, **sirf current power ko variable me store karke** bhi kaam chal jata:

```java
int power = 1;
while(power < n) {
    power *= 3;
}
return power == n;
```

Ye **memory efficient** aur simple hai.


---
---
 #
```java


```
---
---
 #
```java


```
---
---
 #
```java


```
---
---
 #
```java


```
---
---
 #
```java


```
---
---
 #
```java


```
---
---
 #
```java


```
---
---
 #
```java


```
---
---
 #
```java


```
---
---
 #
```java


```
---
---
 #
```java


```
---
---
 #
```java


```
---
---
 #
```java


```
---
---
 #
```java


```
---
---
 #
```java


```
---
---
 #
```java


```
---
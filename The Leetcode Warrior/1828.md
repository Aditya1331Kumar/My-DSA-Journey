# leetcode problem 1828

***8***
---
*** *** 
---

## some important points to leran:

---
 # My soln
```java
class Solution {
    public int[] countPoints(int[][] points, int[][] queries) {
        int count;
        int [] ans = new int[queries.length];
        for (int i = 0 ; i<queries.length ; i++){
            count=0;
             for (int j = 0 ; j<points.length ; j++){
double xele = Math.pow(points[j][0]-queries[i][0] , 2);
double yele =Math.pow(points[j][1]-queries[i][1] , 2);
double d = xele+ yele;
if(d<=(queries[i][2]*queries[i][2])){count ++;}
             }
             ans[i]=count;
        } return ans;
    }
}

```
* Math.pow(a, 2) ≠ simple a*a → time zyada lega.
---
---
 # same logic as above but 60 percent more optimized
```java
class Solution {
    public int[] countPoints(int[][] points, int[][] queries) {
        int[] ans = new int[queries.length];

        for (int i = 0; i < queries.length; i++) {
            int count = 0;
            int qx = queries[i][0], qy = queries[i][1], r = queries[i][2];

            for (int j = 0; j < points.length; j++) {
                int dx = points[j][0] - qx;
                int dy = points[j][1] - qy;
                int dist2 = dx * dx + dy * dy;

                if (dist2 <= r * r) {
                    count++;
                }
            }
            ans[i] = count;
        }

        return ans;
    }
}


```
---
---
 #
```java


```
---
---
 #
```java


```
---
---
 #
```java


```
---
---
 #
```java


```
---
---
 #
```java


```
---
---
 #
```java


```
---
---
 #
```java


```
---
---
 #
```java


```
---
---
 #
```java


```
---
---
 #
```java


```
---
---
 #
```java


```
---
---
 #
```java


```
---
---
 #
```java


```
---
---
 #
```java


```
---
---
 #
```java


```
---
---
 #
```java


```
---
---
 #
```java


```
---
---
 #
```java


```
---
---
 #
```java


```
---
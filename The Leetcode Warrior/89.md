# leetcode problem 89

***8***
---
*** *** 
---

## some important points to leran:

---
 ## bit / binary representation of an integer.

### 🔹 Java

```java
int n = 13;
System.out.println(Integer.toBinaryString(n));
```

Output:

```java
1101
```

### For Java specifically, the most common is:

* Integer.toBinaryString(n) → binary as string

* Integer.bitCount(n) → number of set bits (1s) in binary
---


 #
```java
Math.pow(2, n) 
 Math.exp(2)
 // exponential and power dono k liye

        System.out.println(Math.pow(3, 4));   // 81.0 (3^4)
        System.out.println(Math.exp(1));      // 2.718... (e^1)
        System.out.println(Math.sqrt(16));    // 4.0
        System.out.println(Math.log(10));     // 2.302... (ln(10))
        System.out.println(Math.log10(1000)); // 3.0
    
```
---
---
 #How to check if a number is power of 2?
👉 
```java

xor & (xor - 1) == 0
```
---
---
 #  XOR basics

* `0 ^ 0 = 0`
* `1 ^ 1 = 0`
* `0 ^ 1 = 1`
* `1 ^ 0 = 1`

Matlab XOR **sirf tab 1 deta hai jab dono bits alag ho**.

---

### 2. Example: `x` aur `y` ke XOR ka result

Maan lo:

```java
x = 1010
y = 1110
```

XOR:

```java
1010
1110
----
0100
```

Result = `0100` → matlab bas **ek bit different tha** (3rd position).

---

### 3. Condition for “only 1 bit change”

Jab tum `x ^ y` karte ho:

* Agar result mein **exactly 1 bit set hai** → matlab `x` aur `y` bas ek hi bit mein differ karte hain.
* Agar result mein multiple `1`s hain → matlab ek se zyada bit different hain.
* Agar result = `0` → matlab bilkul same hain (koi bit change nahi).


---
---
 # Our Ans Jo Maine 85% socha
```java



class Solution {
    public List<Integer> grayCode(int n) {
        int size = 1 << n; // 2^n
        List<Integer> list = new ArrayList<>();
        boolean[] visited = new boolean[size];
        
        int temp = 0;
        list.add(temp);
        visited[temp] = true;
        
        for (int i = 1; i < size; i++) {
            for (int j = 0; j < n; j++) {
                int next = temp ^ (1 << j); // flip j-th bit
                if (!visited[next]) {
                    list.add(next);
                    visited[next] = true;
                    temp = next;
                    break;
                }
            }
        }
        return list;
    }
}
```

## code explanation:



```java
int next = temp ^ (1 << j);
```

iska matlab hai **"temp se ek naya number banao jisme sirf ek bit flip ho jaye"**.



### Breakdown:

* `1 << j`
  iska matlab hai **1 ko left shift karna**.
  Agar `j = 0` → `1 << 0 = 1` (binary: `0001`)
  Agar `j = 1` → `1 << 1 = 2` (binary: `0010`)
  Agar `j = 2` → `1 << 2 = 4` (binary: `0100`)
  Matlab ye sirf ek position pe `1` banata hai.

* `temp ^ (1 << j)`
  XOR karne se, `temp` ke `j-th` bit **flip** ho jaata hai.

  * Agar bit 0 tha → 1 ho jaayega
  * Agar bit 1 tha → 0 ho jaayega

Toh `next` ka matlab hai: "temp ke j-th bit ko flip karke jo number banta hai".

---

### Example:

maan lo `temp = 3 (011 binary)`

* agar `j=0`:
  `next = 011 ^ 001 = 010 (2)`
  yani bit-0 flip.

* agar `j=1`:
  `next = 011 ^ 010 = 001 (1)`
  yani bit-1 flip.

* agar `j=2`:
  `next = 011 ^ 100 = 111 (7)`
  yani bit-2 flip.



---
 # Next solution (i ^ (i >> 1) ka funda)
```java

class Solution {
    public List<Integer> grayCode(int n) {
        List<Integer> result = new ArrayList<>();
        int total = 1 << n; // 2^n
        
        for (int i = 0; i < total; i++) {
            result.add(i ^ (i >> 1)); // formula: i XOR (i >> 1)
        }
        
        return result;
    }
}


```
---
---
 # Bilkul sahi 👍

* **MSB (Most Significant Bit)** → sabse **left wala bit** (jo number ko sabse zyada weight deta hai).
  Example: `10110` me **MSB = 1** (leftmost bit).

* **LSB (Least Significant Bit)** → sabse **right wala bit** (jo number ko sabse kam weight deta hai).
  Example: `10110` me **LSB = 0** (rightmost bit).


---
---
 #  Gray Code ka Rule

Gray code ka rule ye hai:

* Har successive number **sirf ek bit** se different hoga.
* Pehla number hamesha `0` hota hai.
  Example (3-bit Gray code):

```
Decimal   Binary   Gray
0         000      000
1         001      001
2         010      011
3         011      010
4         100      110
5         101      111
6         110      101
7         111      100
```

Notice: har step mein sirf **1 bit flip** hota hai.

---

### 2. Relation Between Gray & Binary

Gray number ko hum binary se nikalte hain:

* **MSB same hota hai** (sabse bada bit dono mein same).
* **Baaki bits** ke liye:
  Gray\[i] = Binary\[i] ⊕ Binary\[i-1]



### 3. Formula Derivation

Ab dekho formula:

```java
Gray(i) = i ⊕ (i >> 1)
```

Matlab:

* Current number `i` ko lo.
* Usko 1 bit right shift karo (`i >> 1`) → ye "previous binary bit" ki copy ban jata hai.
* Dono ko XOR karo → naya bit Gray ka ban jata hai.

---



### 5. Intuition

* XOR kaam karta hai kyunki **"bit flip detection"** karta hai.
* Jab bhi binary mein ek bit change hota hai → XOR us bit ko Gray ke liye mark kar deta hai.
* Isliye Gray sequence hamesha 1-bit difference maintain karta hai.

---
 # Best Solution
```java
import java.util.AbstractList;

class Solution {
    public List<Integer> grayCode(int n) {
        return new AbstractList<>() {
            @Override
            public int size() {
                return 1 << n;
            }

            @Override
            public Integer get(int index) {
                return index ^ (index >> 1);
            }
        };
    }
}

```
---
---
 #
```java


```
---
---
 #
```java


```
---
---
 #
```java


```
---
---
 #
```java


```
---
---
 #
```java


```
---
---
 #
```java


```
---
---
 #
```java


```
---
---
 #
```java


```
---
---
 #
```java


```
---
---
 #
```java


```
---
---
 #
```java


```
---
---
 #
```java


```
---
# leetcode problem 

***good sum find karne ka binary search***
---
*** *** 
---

## some important points to leran:

---
 # pehla soln jo achha h 


### Quick summary

* Input: sorted array `numbers[]` aur `target`.
* Idea: do pointers — `left` start se, `right` end se.
* Agar `numbers[left] + numbers[right]` target se chhota → `left++` (sum badhana hai).
* Agar sum bada → `right--` (sum ghatana hai).
* Agar equal → return indices (problem expects **1-based** indices, isliye `+1`).

---

### code

```java
class Solution {
    public int[] twoSum(int[] numbers, int target) {
        int left = 0;                      // start index (0-based)
        int right = numbers.length - 1;    // end index

        while (left < right) {             // stop when pointers cross
            int sum = numbers[left] + numbers[right];

            if (sum == target) {
                return new int[]{left + 1, right + 1}; // return 1-based indices
            } else if (sum < target) {
                left++;    // need larger sum → move left forward (bigger values)
            } else {
                right--;   // need smaller sum → move right backward (smaller values)
            }
        }

        return new int[]{-1, -1}; // unreachable if problem guarantees a solution
    }
}
```

---

### Line-by-line logic (detail)



4. `int sum = numbers[left] + numbers[right];`
   — Current pair ka sum calculate. **(Note:** agar values bahut badi ho sakti hain toh `long sum = (long)numbers[left] + numbers[right];` safer hoga — int overflow avoid karne ke liye.**)**

5. `if (sum == target)` → return `left+1, right+1`
   — Problem statement sorted-array variant me indices **1-based** expect karta hai.

6. `else if (sum < target)` → `left++`
   — Sum chhota hai → we need a larger sum. Kyunki array sorted hai, `numbers[left+1] >= numbers[left]`, isliye left ko aage badha ke sum badh sakta hai.

7. `else` → `right--`
   — Sum bada hai → we need smaller sum. Right ko peeche le aane se value ghat-ti hai.

8. `return new int[]{-1, -1};`
   — Problem usually guarantee karta hai ek valid pair exist karega; phir bhi safe fallback.

---


### Time & Space complexity

* **Time:** O(n) — har element pe at most ek baar pointer move hota hai.
* **Space:** O(1) — extra memory constant.

---



 # another soln using hashmaps
```java
class Solution {
    public int[] twoSum(int[] nums, int target) {
       HashMap<Integer, Integer> map = new HashMap<>();
       for(int i=0;i<nums.length;i++){
        int curr = nums[i];
        map.put(nums[i], i);
       }
       for(int i=0;i<nums.length;i++){
        int curr = nums[i];
        int find = target-curr;
        if(map.containsKey(find) && i!=map.get(find)){
            // map.get(find , map.getOrDefault(0,find)+1);
            return new int[]{i+1,map.get(find)+1};
        }
       }
       return new int[]{-1,-1}; 
    }
}

```
---
---
 #
```java


```
---
---
 #
```java


```
---
---
 #
```java


```
---
---
 #
```java


```
---
---
 #
```java


```
---
---
 #
```java


```
---
---
 #
```java


```
---
---
 #
```java


```
---
---
 #
```java


```
---
---
 #
```java


```
---
---
 #
```java


```
---
---
 #
```java


```
---
---
 #
```java


```
---
---
 #
```java


```
---
---
 #
```java


```
---
---
 #
```java


```
---
---
 #
```java


```
---
---
 #
```java


```
---
---
 #
```java


```
---
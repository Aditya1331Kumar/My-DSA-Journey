# leetcode problem 137

***medium jaisa***
---
*** *** 
---

## some important points to leran:



## 🔹 What is `BigInteger`?

* In Java, primitive types like `int` and `long` have fixed sizes (`int = 32 bits`, `long = 64 bits`).
* When numbers go beyond their limits (`int` > 2,147,483,647 or `long` > 9,223,372,036,854,775,807), they **overflow**.
* To handle **arbitrarily large integers** (no limit except memory), Java provides the **`BigInteger` class** in `java.math`.

👉 Example:

```java
import java.math.BigInteger;

class Demo {
    public static void main(String[] args) {
        BigInteger big = new BigInteger("999999999999999999999999999999");
        System.out.println(big.multiply(big));
    }
}
```

✅ This works even though the number is far beyond `long`.

---

## 🔹 How to Create a `BigInteger`

```java
BigInteger a = new BigInteger("123456789");   // from String
BigInteger b = BigInteger.valueOf(1000);      // from long
BigInteger zero = BigInteger.ZERO;            // constants
BigInteger one = BigInteger.ONE;
BigInteger ten = BigInteger.TEN;
```

---

## 🔹 Common Operations

Since you **cannot use operators (`+`, `-`, `*`)** with BigInteger, you must use methods.

### 1. Arithmetic

```java
BigInteger a = new BigInteger("50");
BigInteger b = new BigInteger("20");

BigInteger sum = a.add(b);          // 50 + 20 = 70
BigInteger diff = a.subtract(b);    // 50 - 20 = 30
BigInteger prod = a.multiply(b);    // 50 * 20 = 1000
BigInteger div = a.divide(b);       // 50 / 20 = 2
BigInteger rem = a.remainder(b);    // 50 % 20 = 10
BigInteger[] qr = a.divideAndRemainder(b); // quotient & remainder
```

---

### 2. Power & GCD

```java
BigInteger pow = a.pow(5);    // a^5
BigInteger gcd = a.gcd(b);    // greatest common divisor
```

---

### 3. Comparisons

```java
a.equals(b);                // checks equality
a.compareTo(b);              // returns -1 (a<b), 0 (a=b), 1 (a>b)
```

---

### 4. Bitwise Operations

```java
BigInteger and = a.and(b);
BigInteger or = a.or(b);
BigInteger xor = a.xor(b);
BigInteger not = a.not();
BigInteger shiftLeft = a.shiftLeft(2);   // a << 2
BigInteger shiftRight = a.shiftRight(2); // a >> 2
```

---

### 5. Conversion

```java
int i = a.intValue();           // to int
long l = a.longValue();         // to long
String s = a.toString();        // to String
BigInteger fromBinary = new BigInteger("1010", 2); // binary "1010" -> 10
BigInteger fromHex = new BigInteger("FF", 16);     // hex "FF" -> 255
```

---

### 6. Other Useful Methods

```java
BigInteger abs = a.abs();             // absolute value
BigInteger neg = a.negate();          // -a
boolean prime = a.isProbablePrime(10); // primality test
BigInteger mod = a.mod(b);            // a % b (positive result)
BigInteger modPow = a.modPow(b, m);   // (a^b) % m
BigInteger modInverse = a.modInverse(m); // modular inverse
```

---

## 🔹 When to Use `BigInteger`?

* **Cryptography** (RSA, ECC) → needs very large primes.
* **Combinatorics / Factorials** → factorial(1000) doesn’t fit in `long`.
* **Competitive Programming** (when dealing with huge inputs).
* **Exact big calculations** (financial systems, scientific simulations).

---

## 🔹 Example: Factorial Using BigInteger

```java
import java.math.BigInteger;

class Factorial {
    public static void main(String[] args) {
        int n = 50;
        BigInteger fact = BigInteger.ONE;
        for (int i = 2; i <= n; i++) {
            fact = fact.multiply(BigInteger.valueOf(i));
        }
        System.out.println("50! = " + fact);
    }
}
```

---

## 🔑 Quick Reference Table

| Operation          | Method                      |
| ------------------ | --------------------------- |
| Add                | `add(BigInteger val)`       |
| Subtract           | `subtract(BigInteger val)`  |
| Multiply           | `multiply(BigInteger val)`  |
| Divide             | `divide(BigInteger val)`    |
| Modulo             | `mod(BigInteger val)`       |
| Power              | `pow(int exponent)`         |
| GCD                | `gcd(BigInteger val)`       |
| Compare            | `compareTo(BigInteger val)` |
| Bitwise AND        | `and(BigInteger val)`       |
| Convert to int     | `intValue()`                |
| Convert to String  | `toString()`                |
| Binary / Hex parse | `new BigInteger("1010", 2)` |

* BigInteger par % operator nahi chalta
```java
BigInteger sum = BigInteger.ZERO;

```

* Tumhe .mod() aur .divide() use karna hoga

---
 # Aur Geharai mein 
### 🔹 Normal integer limits

* `int` → 32 bit → range: **−2,147,483,648 to 2,147,483,647**
* `long` → 64 bit → range: **−9,223,372,036,854,775,808 to 9,223,372,036,854,775,807**

Agar number is range se bada ho jaye → **overflow** ho jata hai.

---

### 🔹 BigInteger

* `BigInteger` ek **class** hai (in `java.math` package).
* Ye theoretically unlimited precision ka integer store kar sakti hai (limited by memory only).
* Isme +, −, ×, ÷, mod, power, gcd etc. sab functions available hote hain.

---
 # The Soln:
```java
import java.util.*;

class Solution {
    public int singleNumber(int[] nums) {
        Map<Integer, Integer> map = new HashMap<>();
        
        for (int num : nums) {
            map.put(num, map.getOrDefault(num, 0) + 1);
        }
        
        for (int key : map.keySet()) {
            if (map.get(key) == 1) return key;
        }
        
        return -1; // should never reach here
    }
}


```
---
---
 # Assan 
```java

class Solution {
    public int singleNumber(int[] nums) {
        Arrays.sort(nums);

        for (int i = 0; i < nums.length - 2; i += 3) {
            if (nums[i] != nums[i + 1]) {
                return nums[i];
            }
        }

        return nums[nums.length - 1];
    }
}
```
---
---
 # Isme sikhna h : shyd Kunal Khushwaha jaisa lets see
```java
class Solution {
    public int singleNumber(int[] nums) {
        int ans = 0;
        for (int i=0;i<32;i++) {
            // ava ke int me 32 bits hote hain (0…31).

// hum har bit position par jaake count karenge ki kitni baar 1 aayi.
            int count = 0;
            for (int j=0;j<nums.length;j++) {
                int x = nums[j] & (1<<i);
                if (x != 0) {
                    count++;
                }
            }

            if (count % 3 != 0) {
                ans = ans | (1<<i);
            }
        }
        return ans;
    }
}
```
### array me har number 3-3 baar aata hai, sirf ek number 1 baar. agar hum har bit position (0 se 31) par kitni baar 1 aayi hai, wo ginte rahein, to jo numbers 3-3 baar aate hain unka contribution 3 ka multiple hoga. unique number jis bit par 1 deta hai, us bit ki total count % 3 == 1 (non-zero) ho jayegi. isi se hum final number reconstruct kar lete hain.


great choice—yeh **bit-counting (mod-3)** wala solution optimal hai. chalo isko bilkul line-by-line, intuition ke saath samjhte hain.

```java
class Solution {
    public int singleNumber(int[] nums) {
        int ans = 0;
        for (int i=0;i<32;i++) {
            int count = 0;
            for (int j=0;j<nums.length;j++) {
                int x = nums[j] & (1<<i);
                if (x != 0) {
                    count++;
                }
            }

            if (count % 3 != 0) {
                ans = ans | (1<<i);
            }
        }
        return ans;
    }
}
```

# kya idea hai?

array me har number 3-3 baar aata hai, sirf **ek** number 1 baar.
agar hum **har bit position** (0 se 31) par kitni baar `1` aayi hai, wo ginte rahein, to jo numbers 3-3 baar aate hain unka contribution **3 ka multiple** hoga. unique number jis bit par `1` deta hai, us bit ki total count `% 3 == 1` (non-zero) ho jayegi. isi se hum final number reconstruct kar lete hain.

---

# line-by-line

### `int ans = 0;`

* yahi final answer banega. initially saare bits `0`.

### `for (int i=0; i<32; i++) { ... }`

* Java ke `int` me **32 bits** hote hain (0…31).
* hum har bit position par jaake count karenge ki kitni baar `1` aayi.

### `int count = 0;`

* current bit position `i` par total `1`s ka counter.

### inner loop: `for (int j=0; j<nums.length; j++) { ... }`

* array ke har element ko check karte hain.

### `int x = nums[j] & (1<<i);`

* `(1<<i)` ek **mask** banata hai jisme sirf `i`-th bit set hoti hai.

  * ex: i=0 → `...0001`, i=1 → `...0010`, i=2 → `...0100`, …
* `nums[j] & mask` kare to:

  * agar `nums[j]` ke `i`-th bit me `1` hai, result **non-zero** aayega (mask hi).
  * agar `0` hai to result `0`.

### `if (x != 0) count++;`

* agar us number ka `i`-th bit set mila, to `count` badha do.

### `if (count % 3 != 0) { ans = ans | (1<<i); }`

* saare numbers jo 3-3 baar repeat ho rahe the, unka contribution is bit par **3 ka multiple** ban gaya hoga.
* agar `% 3 != 0`, iska matlab **unique number** ne is bit par `1` diya hoga.
* to `ans` me wo bit **set** kar do: `ans |= (1<<i)`.

### `return ans;`

* 32 bits process hone ke baad reconstructed number mil jata hai.

---

# quick dry-run (mini)

`nums = [2,2,3,2]` → expected = 3

* binary: `2 = 10`, `3 = 11`

bit `i=0` (LSB):

* numbers ke LSBs: `2(0),2(0),3(1),2(0)` → count = 1 → `1 % 3 = 1` → ans bit0 = 1

bit `i=1`:

* second bit: `2(1),2(1),3(1),2(1)` → count = 4 → `4 % 3 = 1` → ans bit1 = 1

baaki bits par count % 3 = 0 → set nahi hote.
ans bits: `…0011` = **3** ✅

---

# negatives ka kya?

* Java `int` signed 32-bit hota hai (two’s complement).
* jab `i = 31` (sign bit) hoga, `(1<<31)` ka value `0x80000000` (negative int) ban jata hai—**ye valid hai**.
* agar unique number negative hai aur uska sign bit set hai, to `count % 3 != 0` par hum `ans` ka sign bit set kar denge, jis se `ans` negative ban jayega—exactly sahi behavior.

> dhyan: hum kahin bhi right-shift (`>>`) se sign-extension use nahi kar rahe, sirf mask & OR kar rahe hain, isliye sign handling natural aur sahi rehti hai.

---

# complexity

* **Time:** 32 \* n ≈ **O(n)**
* **Space:** **O(1)** (sirf akele counters/masks)

---

# chhote polish/variants (optional)

* enhanced for-loop se slightly cleaner:

  ```java
  for (int i = 0; i < 32; i++) {
      int count = 0;
      for (int num : nums) {
          if ((num & (1 << i)) != 0) count++;
      }
      if (count % 3 != 0) ans |= (1 << i);
  }
  ```
* agar kabhi 64-bit `long` pe kaam karo to loop 64 tak karna.

---

yeh solution interview-grade optimal hai. agar chaho to main isi idea ko **“k appears, others appear m times”** generic template me convert karke de du (mod-m reconstruction), ya phir **bitmask state machine** (ones/twos) ka intuition diagram ke saath samjha du.

---
 # Code mein likha tha:

```java
ans |= (1 << i);
```

### Step 1: `(1 << i)` ka matlab

* `1 << i` ka matlab hai **left shift** operator.
* Ye **1 ko i position left shift** karega.

  * Agar `i = 0` → `1 << 0 = 1` (binary: `0001`)
  * Agar `i = 1` → `1 << 1 = 2` (binary: `0010`)
  * Agar `i = 2` → `1 << 2 = 4` (binary: `0100`)
  * Agar `i = 3` → `1 << 3 = 8` (binary: `1000`)

👉 basically ye ek mask banata hai jisme sirf ek bit set hoti hai.

---

### Step 2: `ans |= (...)` ka matlab

* Ye **bitwise OR assignment operator** hai.
* `ans |= (1 << i);` ka matlab hai:

```java
ans = ans | (1 << i);
```

* Matlab: `ans` ke i-th bit ko **set** kar do.
* Agar wo bit pehle 0 thi to 1 ho jayegi. Agar already 1 thi to waise hi 1 rahegi.

---

### Example

Maan lo abhi:

```java
ans = 0;   // binary: 0000
i = 2;
```

* `(1 << i) = (1 << 2) = 4` (binary: `0100`)
* `ans = ans | 4`

  * `0000 | 0100 = 0100`
* To `ans = 4` ho gaya.

Agar agla step i = 0 ho:

* `(1 << 0) = 1` (binary: `0001`)
* `ans = 0100 | 0001 = 0101` → `5`

---

👉 To iska kaam hai **answer number ko bit by bit construct karna**.
Har wo bit jaha count % 3 ≠ 0 hoga, waha wo bit ans mein set kar di jayegi.

---

Kya chahoge mai is line `ans |= (1<<i)` ko ek **real dry run example** ke sath karke dikhau, taki aur clear ho jaye?

---
---
 #
```java


```
---
---
 # Another good and the most optimized soln:badiya! { **bitmask state machine**}

```java
class Solution {
    public int singleNumber(int[] nums) {
        int n = nums.length;
        int ones = 0;
        int twos = 0;
        for (int i = 0; i < n; i++) {
            ones = (ones ^ nums[i]) & ~twos;
            twos = (twos ^ nums[i]) & ~ones;
        }
        return ones;
    }
}
```

# core idea (per bit)

* har bit position ko **independently** socho.
* `ones` = un bits ka set jinko ab tak **(count % 3 == 1)** times dekha hai.
* `twos` = un bits ka set jinko ab tak **(count % 3 == 2)** times dekha hai.
* koi bit kabhi dono me saath me nahi hota (disjoint), aur jab kisi bit ko **3rd** baar dekhte ho to dono se nikal kar **0** ho jata (count % 3 == 0).

is tarah har bit ka state cycle hota hai:

```
(0,0) --1st time--> (0,1)  // ones
(0,1) --2nd time--> (1,0)  // twos
(1,0) --3rd time--> (0,0)  // cleared
```

(jahan (twos,ones) dikhaya hai)

# update formulas ka matlab

1. `ones = (ones ^ x) & ~twos;`

   * `ones ^ x` : x ke set bits ko `ones` me **toggle** karo (aaya to add, dubara aaya to remove).
   * `& ~twos` : jo bits abhi `twos` me pahunch gaye, unhe `ones` se **saaf** kar do (disjoint rakhna hai).

2. `twos = (twos ^ x) & ~ones;`

   * `twos ^ x` : x ke set bits ko `twos` me **toggle** karo.
   * `& ~ones` : ab **updated** `ones` ko use karke ensure karo ki koi bit `twos` me tabhi rahe jab wo `ones` me na ho (disjoint).
   * **order important hai**: pehle `ones` update hota hai, fir `twos` us updated `ones` ko dekh kar clean hota hai.

loop ke baad:

* jo bits exactly 1 baar aayi (mod 3 == 1) woh `ones` me rahengi → **answer = ones**.
* `twos` me woh bits hoti jo mod 3 == 2, lekin problem me final unique number mod 3 == 1 hota hai, isliye `twos` return nahi karte.

# mini dry run: nums = \[2,2,3,2]

(binary: 2=10, 3=11)

* start: `ones=00, twos=00`

x=2 (10):

* ones = (00 ^ 10) & \~00 = 10
* twos = (00 ^ 10) & \~10 = 00

x=2 (10):

* ones = (10 ^ 10)=00 & \~00 = 00
* twos = (00 ^ 10)=10 & \~00 = 10

x=3 (11):

* ones = (00 ^ 11)=11 & \~10 = 01
* twos = (10 ^ 11)=01 & \~01 = 00

x=2 (10):

* ones = (01 ^ 10)=11 & \~00 = 11
* twos = (00 ^ 10)=10 & \~11 = 00

end: `ones = 11b = 3` → ✅

# negatives?

two’s-complement me sign bit bhi bas ek normal bit hi hai. ye logic har bit ko mod-3 counter ki tarah treat karta hai, to negative unique numbers bhi sahi reconstruct hote hain (sign bit 3 se mod karke set/clear ho jata).

# complexity

* time: **O(n)** (har element ek baar process)
* space: **O(1)** (sirf `ones`, `twos`)

# teen takeaways

* `^` (XOR) se “toggle” hota hai → occurrences ko mod 2 style flip karo.
* `& ~mask` se “clear” hota hai → disjoint states maintain.
* order matters: pehle `ones`, fir `twos`.

agar chaho to isi pattern ko generalize karke “others appear **k** times” ke liye 2 se zyada masks ke saath **mod-k** state machine bhi bana sakte hain.

---
 # Theek hai — aao is `ones/twos` trick ko **bahut hi dhire—dhire** aur **bahut detail** me samjhte hain, per-bit basis se start karke, truth-table + example tak. Hindi + code mix karunga taaki sab clear ho.

---

# Quick reminder — code

```java
ones = (ones ^ x) & ~twos;
twos = (twos ^ x) & ~ones;   // note: ones is the updated value here
```

Yahan `x = nums[i]` (poora integer), operators:

* `^` = XOR (toggle bits)
* `&` = bitwise AND
* `~` = bitwise NOT (invert bits)
* `|` = bitwise OR (not used here)

---

# Intuition (per bit)

Har **bit position** (0..31) ko alag socho.
Har position par hum “us bit ka **count mod 3**” track karna chahte hain (kyunki sab numbers 3 baar aate hain except ek).

Hum do bitmasks rakhte hain (poore integer ke liye):

* `ones`  — woh bits jinka **count % 3 == 1** hai.
* `twos`  — woh bits jinka **count % 3 == 2** hai.

Is encoding se:

```
count % 3 == 0  -> ones=0, twos=0
count % 3 == 1  -> ones=1, twos=0
count % 3 == 2  -> ones=0, twos=1
```

(Notice: ones aur twos kabhi dono 1 nahi ho sakte)

Har baar jab koi number `x` aata hai, uske bits (`b`) ko upar wale state par “add” karna hai (mod 3). Yeh exactly state transition hai:

state cycle for a bit when b=1 repeatedly:

```
00 (0) -> 10 (1) -> 01 (2) -> 00 (0) -> ...
```

---

# Kyon yeh formulas:

`ones = (ones ^ x) & ~twos;`

1. `ones ^ x` : agar current bit `x` me 1 hai to woh bit ones me toggle ho jayega (agar pehle 0 tha to 1, agar pehle 1 tha to 0).
2. `& ~twos` : lekin agar pebale se `twos` me wo bit set hai (count already 2), to hum `ones` me us bit ko rakhna **nahi** chahte — kyunki 3rd occurrence pe us bit ko clear karna hai. Isliye `& ~twos` clear karta hai woh bits jaha `twos` = 1.

`twos = (twos ^ x) & ~ones;` (yahan `ones` is updated ones)

1. `twos ^ x` : toggle twos with input.
2. `& ~ones` : par hum ensure karte hain ki agar updated `ones` me koi bit ab set ho gaya (count became 1 after XOR), to us bit ko `twos` me na rakhen (disjointness).

Order important: **pehle ones update, fir twos**. Kyunki hum chahte hain twos ke liye `~ones` use karein jisme ones ka naya state ho.

---

# Truth table (per single bit)

Chalo ek simple table banaate hain jahan `o` = old ones bit, `t` = old twos bit, `b` = input bit (x's bit).
Phir compute karte hain `o'` (new ones) aur `t'` (new twos). (Remember: new ones computed first, then new twos uses new ones.)

```
o t b  | o^b   o' = (o^b)&~t   t^b   t' = (t^b)&~o'
--------------------------------------------------
0 0 0 |  0      0              0      0        => (0,0)
0 0 1 |  1      1              1      0        => (1,0)
1 0 0 |  1      1              0      0        => (1,0)
1 0 1 |  0      0              1      1        => (0,1)
0 1 0 |  0      0              1      1        => (0,1)
0 1 1 |  1      0              0      0        => (0,0)
```

Yeh table exactly wo cycle dikhata hai:

* From (0,0) with b=1 → (1,0)   // count becomes 1
* From (1,0) with b=1 → (0,1)   // count becomes 2
* From (0,1) with b=1 → (0,0)   // count becomes 0 (3rd time, cleared)

Aur agar b=0 (input bit zero) state unchanged (kuch toggles happen but masking keeps same).

---

# Step-by-step numeric example (full integers)

Take example `nums = [2,2,3,2]` (binary: 2=`10`, 3=`11`). We'll show `ones` and `twos` in binary (only low 2 bits shown):

Start: `ones=00`, `twos=00`.

1. x = 2 (`10`):

* ones = (00 ^ 10) & \~00 = 10 & 11 = **10**
* twos = (00 ^ 10) & \~10 = 10 & 01 = **00**
  \=> ones=10, twos=00

2. x = 2 (`10`) again:

* ones = (10 ^ 10) & \~00 = 00 & 11 = **00**
* twos = (00 ^ 10) & \~00 = 10 & 11 = **10**
  \=> ones=00, twos=10   (means bit1 has count%3 == 2)

3. x = 3 (`11`):

* ones = (00 ^ 11) & \~10 = 11 & 01 = **01**
* twos = (10 ^ 11) & \~01 = 01 & 10 = **00**
  \=> ones=01, twos=00   (now LSB (bit0) count=1, MSB(bit1) becomes back to count 0 because 3rd occurrence cleared)

4. x = 2 (`10`):

* ones = (01 ^ 10) & \~00 = 11 & 11 = **11**
* twos = (00 ^ 10) & \~11 = 10 & 00 = **00**
  \=> ones=11, twos=00  => ones contains `11` which is decimal 3 → answer.

See how across the whole integer the bitwise ops operate on all bits simultaneously. We didn't treat bits separately in code; the bitwise logic just does it for all 32 bits at once.

---

# Why final answer = `ones`?

At the end:

* For every bit position, after processing all numbers, `ones` has 1 exactly for those bit positions where the total count of 1s ≡ 1 (mod 3). That exactly corresponds to the unique number whose bits appear once.
* `twos` would contain bits with count ≡ 2 (mod 3), which we don't need.

---

# Why this is O(1) space and safe for negatives

* We use only two `int` variables (`ones`, `twos`) — O(1) extra memory.
* Negative numbers: sign bit (31st bit) is processed same way — it will end up set in `ones` if the unique negative number has sign bit = 1. Two’s complement arithmetic is naturally handled since we treat sign bit like any other bit.

---

# Important implementation note (order!)

**Order matters** — must update `ones` first, then `twos` using the updated `ones`. If you swapped order, the mask `~ones` would use the old ones and logic will break.

---

# Short visual summary

* `^` toggles occurrence for incoming bits.
* `& ~twos` clears bits that already have count 2 (so 3rd occurrence clears).
* `twos` formula uses updated `ones` to keep `ones` and `twos` disjoint.

---

Koi particular step abhi bhi unclear hai? Chaho to main:

* ek aur **very low-level per-bit table** banaun for a specific bit with a sequence of inputs, ya
* ek **visual diagram** (state machine arrows) banaun, ya
* isi solution ka **line-by-line annotated code** (har line ka comment) de dun?

Batao, kaunsa format tumhe best lagega — mai turant bana dunga.

---
---
 #
```java


```
---
---
 #
```java


```
---
---
 #
```java


```
---
---
 #
```java


```
---
---
 #
```java


```
---
---
 #
```java


```
---
---
 #
```java


```
---
---
 #
```java


```
---
---
 #
```java


```
---
---
 #
```java


```
---
---
 #
```java


```
---
---
 #
```java


```
---
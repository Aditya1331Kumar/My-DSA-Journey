# leetcode problem 

***jhaatu***
---
*** *** 
---

## some important points to leran:

---
 # standard 
```java

class Solution {
    public int[] findErrorNums(int[] arr) {
        int i = 0;
        while(i < arr.length){
            int correct = arr[i] - 1;
            if(arr[i] != arr[correct]){
                swap(arr, i , correct);
                
            }else{
                i++;
            }
        }
        for(int index = 0; index < arr.length; index++){
            if(arr[index] != index + 1){
                return new int [] {arr[index], index + 1};
            }
        }
        return new int [] {-1, -1};
    }
    void swap(int [] arr, int first, int second){
        int temp = arr[first];
        arr[first] = arr[second];
        arr[second] = temp;
    }
}
```
---
---
 # another soln
Nice — great alternate solution. I’ll explain it **line-by-line**, do a **dry run**, show **why it works**, list **complexity**, **edge cases**, and a few **notes/improvements**.

---

### 1) The code (with inline comments)

```java
class Solution {
    public int[] findErrorNums(int[] nums) {
        int[] count = new int[nums.length];   // count[i] will store frequency of value (i+1)
        int[] result = new int[2];            // result[0]=duplicate, result[1]=missing

        // Count frequencies
        for (int i = 0; i < nums.length; i++) {
            count[nums[i] - 1]++;             // map value v to index v-1 and increment
        }

        // Find which value occurred twice and which didn't occur
        for (int i = 0; i < nums.length; i++) {
            if (count[i] == 2) {             // frequency 2 -> duplicate value = i+1
                result[0] = i + 1;
            } else if (count[i] == 0) {      // frequency 0 -> missing value = i+1
                result[1] = i + 1;
            }
        }
        return result;
    }
}
```
### 3) Dry run (example)

Input: `nums = [1, 2, 2, 4]` (n = 4)

* `count` initially = `[0,0,0,0]`

After first loop:

* read `1` → `count[0]++` → `[1,0,0,0]`
* read `2` → `count[1]++` → `[1,1,0,0]`
* read `2` → `count[1]++` → `[1,2,0,0]`
* read `4` → `count[3]++` → `[1,2,0,1]`

Second loop (scan index→value = i+1):

* i=0 → count\[0]=1 → ignore
* i=1 → count\[1]=2 → duplicate = `2` (result\[0]=2)
* i=2 → count\[2]=0 → missing = `3`   (result\[1]=3)
* i=3 → count\[3]=1 → ignore

Return `[2, 3]` ✅


---
---
 #
```java


```
---
---
 #
```java


```
---
---
 #
```java


```
---
---
 #
```java


```
---
---
 #
```java


```
---
---
 #
```java


```
---
---
 #
```java


```
---
---
 #
```java


```
---
---
 #
```java


```
---
---
 #
```java


```
---
---
 #
```java


```
---
---
 #
```java


```
---
---
 #
```java


```
---
---
 #
```java


```
---
---
 #
```java


```
---
---
 #
```java


```
---
---
 #
```java


```
---
---
 #
```java


```
---
---
 #
```java


```
---
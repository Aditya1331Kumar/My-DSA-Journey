# leetcode problem 16

***8***
---
*** *** 
---

## some important points to leran:

---
# standard soln
```java
 class Solution {
    public int threeSumClosest(int[] nums, int target) {
        Arrays.sort(nums);
        int n = nums.length;
        // initialize bestSum to first triplet (safe starting point)
        int bestSum = nums[0] + nums[1] + nums[2];

        for (int i = 0; i < n - 2; i++) {
            int left = i + 1;
            int right = n - 1;

            while (left < right) {
                int sum = nums[i] + nums[left] + nums[right];

                // exact match -> best possible
                if (sum == target) return sum;

                // update best if this sum is closer
                if (Math.abs(sum - target) < Math.abs(bestSum - target)) {
                    bestSum = sum;
                }

                // move pointers using sum vs target
                if (sum > target) {
                    right--;
                } else {
                    left++;
                }
            }
        }

        return bestSum;
    }
}

```
---
---
# Dusra achha soln tabadtod h ye hard vhi
```java

class Solution {
    public int threeSumClosest(int[] nums, int target) {
        // Step 1: Counting sort using a byte array for range [-1000, 1000]
        byte[] occurrences = new byte[2001];
        for (int num : nums)
            occurrences[num + 1000]++; // Shift index to 0–2000 range

        // Step 2: Reconstruct sorted nums from occurrences
        for (int count = 0, index = 0; count < 2001; count++) {
            for (int repetitions = occurrences[count]; repetitions-- > 0; ) {
                nums[index++] = count - 1000;
            }
        }

        // Step 3: Initialize pointers and closest sum tracker
        int low = 0, high = nums.length - 1;
        int closestSum = Integer.MAX_VALUE;

        // Step 4: Optimize the low pointer range based on minimum achievable sum
        int minDiff = target - nums[high - 1] - nums[high];
        for (int end = high - 2; low < end && nums[low + 1] <= minDiff; low++);

        // Step 5: Optimize the high pointer range based on maximum achievable sum
        int maxDiff = target - nums[low] - nums[low + 1];
        for (int end = low + 2; high > end && nums[high - 1] >= maxDiff; high--);

        // Step 6: Apply optimized two-pointer approach within reduced bounds
        for (int end = high - 1; low < end; low++) {
            int i = high;
            int j = low + 1;

            while (j < i) {
                int sum = nums[low] + nums[j] + nums[i];

                if (sum == target) {
                    // Found exact match
                    return sum;
                }

                // Check if this sum is closer to target
                if (Math.abs(sum - target) < Math.abs(closestSum - target)) {
                    closestSum = sum;
                }

                // Move pointers based on comparison
                if (sum > target) {
                    i--;
                } else {
                    j++;
                }
            }
        }

        return closestSum;
    }
}

```
---
---
# code breakdown of above one 

Bhai, ekdum step-by-step karte hain — main har block ka matlab, kyun likha gaya hai, aur ek chhota dry-run bhi dunga. Code jo tumne diya hai woh ek **optimized threeSumClosest** — pehle counting sort karta hai (kyunki value range choti hai), phir two-pointer search ko chote bounds tak shrink karta hai. Chalo shuru karte hain.

---

## 1) Overall idea (one-line)

* Pehle array ko **O(n + range)** time me sort kar lo (counting sort).
* Phir sorted array pe two-pointer trick chalake woh triplet find karo jiska sum `target` ke sabse kareeb ho.
* Extra: `low` aur `high` ko pre-shrink karke search space kam kar diya gaya hai (heuristic / safe bounds).

---

## 2) Counting sort (range: `[-1000, 1000]`)

```java
byte[] occurrences = new byte[2001];
for (int num : nums)
    occurrences[num + 1000]++;   // shift: -1000 -> index 0, 0 -> 1000, 1000 -> 2000

// reconstruct
for (int count = 0, index = 0; count < 2001; count++) {
    for (int repetitions = occurrences[count]; repetitions-- > 0; ) {
        nums[index++] = count - 1000;
    }
}
```

* `occurrences[k]` = how many times value `k-1000` appears.
* Iterating `count` from `0..2000` reconstructs `nums` in **ascending** order.
* **Note / caveat:** `byte` can overflow if some value appears >127 times. Safer: `short[]` ya `int[]` for counts.

**Why counting sort?** Typical LeetCode constraint for this problem: each element in `[-1000,1000]`. Counting sort is faster than `Arrays.sort` for many elements in small fixed range.

---

## 3) Init pointers & tracker

```java
int low = 0, high = nums.length - 1;
int closestSum = Integer.MAX_VALUE;
```

* `low` and `high` are global bounds we will reduce.
* `closestSum` stores the **best triplet sum seen so far**. Here they use `Integer.MAX_VALUE` as a sentinel; the first actual triplet will replace it because `Math.abs(sum-target)` will be much smaller.

*(Alternative: initialize `closestSum = nums[0]+nums[1]+nums[2]` for clarity.)*

---

## 4) Pre-shrink `low` (left bound)

```java
int minDiff = target - nums[high - 1] - nums[high];
for (int end = high - 2; low < end && nums[low + 1] <= minDiff; low++);
```

**Meaning / derivation:**

* `minDiff = target - (nums[high-1] + nums[high])`.
* If `a = nums[low+1]` and `a <= minDiff`, then

  ```
  a + nums[high-1] + nums[high] <= target.
  ```

  i.e., **even pairing `a` with the two largest numbers still gives a sum ≤ target**.
* So indices `<= low+1` are "too small" in the sense that they cannot produce sums greater than `target` even when combined with the two largest elements. The loop `low++` moves the `low` forward while this condition holds. `end = high-2` ensures there remain at least two elements to the right for any triplet.

**Why do this?** It's a heuristic / safe bound to skip very small left values that won't help locate sums on the higher side. It reduces the number of `low` iterations later.

---

## 5) Pre-shrink `high` (right bound) — symmetric

```java
int maxDiff = target - nums[low] - nums[low + 1];
for (int end = low + 2; high > end && nums[high - 1] >= maxDiff; high--);
```

**Meaning / derivation:**

* `maxDiff = target - (nums[low] + nums[low+1])`.
* If `b = nums[high-1]` and `b >= maxDiff`, then

  ```
  nums[low] + nums[low+1] + b >= target.
  ```

  i.e., **even pairing `b` with the two smallest numbers yields a sum ≥ target**.
* So very large `high` values that always push triplet sums above `target` can be decremented (excluded), because they cannot help find sums *below* target and likely won't be the closest.

Again `end = low+2` ensures at least two elements left for a triplet.

---

## 6) Two-pointer over reduced bounds

```java
for (int end = high - 1; low < end; low++) {
    int i = high;
    int j = low + 1;

    while (j < i) {
        int sum = nums[low] + nums[j] + nums[i];

        if (sum == target) return sum;

        if (Math.abs(sum - target) < Math.abs(closestSum - target)) {
            closestSum = sum;
        }

        if (sum > target) i--;
        else j++;
    }
}
```

* Outer `for` loops `low` from current `low` up to `end-1` where `end = high-1`. (They used `low` declared earlier as loop control.)
* For each fixed `low`, use two pointers `j = low+1` and `i = high` to scan possible pairs on the right.
* `sum` is current triplet sum. If exact match → return immediately (best possible).
* Update `closestSum` if this `sum` is **closer** to `target` than previous best.
* Move pointers:

  * If `sum > target` → decrease `i` to reduce sum.
  * Else → increase `j` to increase sum.
* Classic sorted-array two-pointer technique.

---

## 7) Example dry-run (small)

Take `nums = [-1, 2, 1, -4]`, `target = 1`.

1. Counting sort → sorted `nums = [-4, -1, 1, 2]`.
2. `low = 0`, `high = 3`. `closestSum = INF`.
3. `minDiff = 1 - nums[2] - nums[3] = 1 - 1 - 2 = -2`.
   `nums[low+1] = nums[1] = -1 <= -2 ?` No → low stays 0.
4. `maxDiff = 1 - nums[0] - nums[1] = 1 - (-4) - (-1) = 6`.
   `nums[high-1] = nums[2] = 1 >= 6 ?` No → high stays 3.
5. Now main loop `end = high - 1 = 2`. Condition `low < end` → `0 < 2` true.

   * low=0, i=3, j=1:

     * sum = -4 + (-1) + 2 = -3. `closestSum` updated to -3 (| -3 - 1| = 4 < INF).
     * sum < target → j++ → j=2 (j == i → break inner).
   * low++ → low=1 (still low < end? 1 < 2 true):

     * i=3, j=2:

       * sum = -1 + 1 + 2 = 2. |2 - 1| =1 < | -3 - 1| =4 → `closestSum = 2`.
       * sum > target → i-- → i=2 now j==i break.
   * low++ → low=2, loop condition `low < end` false → stop.
6. Return `closestSum = 2`. (Correct.)

---

## 8) Complexity

* Counting sort: `O(n + R)` where `R = 2001` (constant) → effectively `O(n)`.
* Reconstruct: `O(n)`.
* Two-pointer search: worst-case `O(n^2)` (but shrinked by optimizations).
* Space: `O(R) = O(1)` extra (2001 sized array), plus `O(1)` variables.

---

## 9) Practical caveats & improvements

1. **Use `int[]` (or short\[]) for `occurrences`** instead of `byte[]` to avoid overflow if a value repeats >127 times.
2. **Initialize `closestSum` safer**: use `nums[0]+nums[1]+nums[2]` after sorting (requires `n >= 3`) — clearer than `Integer.MAX_VALUE` sentinel.
3. **Bounds correctness**: code assumes `nums.length >= 3`. Check/return early otherwise.
4. **Are the pre-shrinks always safe?** They are heuristics derived from inequalities and generally safe for pruning—but if you’re ever unsure, you can remove the two pre-shrink loops and the algorithm still works (just maybe a bit slower).
5. **Avoid `Math.abs` overflow**: not an issue here because numbers limited (\[-1000,1000]). If numbers were large, use `long` for sums and `Math.abs(long)` pattern.
6. **Edge cases with many duplicates**: counting sort handles duplicates fine; but ensure counts use a wide enough type.

---

## 10) Short checklist for correctness

* Sorted ascending? ✅ (counting sort reconstructs ascending)
* Are `end` values chosen so there are always two elements to complete a triplet? ✅ (`high-2` and `low+2` guards)
* Do pointer moves follow `sum vs target` logic? ✅
* Do we update `closestSum` with actual sum, not diff? ✅ (we compare diffs but store `sum`)

---

Agar chahoge, main abhi **tumhare exact code** mein 3 chhote fixes karke phir se likh ke de doon:

* `occurrences` → `int[]`
* `closestSum` init to `nums[0]+nums[1]+nums[2]`
* small `n<3` check

Bol do, mai turant modify karke bhej dunga aur ek aur detailed dry-run dunga.

---
---
```
4.
```
---
---
```
5.
```
---
---
```
6.
```
---
---
```
7.
```
---
---
```
8.
```
---

---
```
9.
```
---
---
```
10.
```
---

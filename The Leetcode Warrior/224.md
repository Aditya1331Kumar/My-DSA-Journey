# leetcode problem 224

***Good one the best one***
---
*** *** 
---

## some important points to leran:

---
 # **`char` to `int`**

---

## 🔹 1. Character ka **ASCII / Unicode value** lena

```java
char c = 'A';
int ascii = c;  // automatic conversion
System.out.println(ascii); // 65
```


## 🔹 2. Agar digit char ho (e.g. `'5'`) → uska actual number chahiye

```java
char c = '5';
int num = c - '0';
System.out.println(num); // 5
```


## 🔹 3. Wrapper class se

```java
char c = '7';
int num = Character.getNumericValue(c);
System.out.println(num); // 7
```


## 🔹 4. String bana kar parse karna

```java
char c = '9';
int num = Integer.parseInt(String.valueOf(c));
System.out.println(num); // 9
```

---
 # Soch process


## 🔹 Step 1: Question samajhna

* Input: ek string expression `"1 + (2 - 3)"`
* Allowed operators: `+`, `-`
* Parentheses `(` `)` allowed
* Digits ho sakte hai multi-digit aur beech me spaces bhi.

👉 Matlab ye ek **expression evaluation** problem hai. Multiplication/division nahi, sirf plus/minus aur parentheses.

---

## 🔹 Step 2: Observe constraints

* `+` aur `-` ke alawa kuch nahi → simple hai.
* Parentheses hain → iska matlab recursion ya stack use hoga.
* Digits multi-digit ho sakte hain → number build karna padega (`num = num*10 + digit`).
* Spaces ignore karne honge.

---

## 🔹 Step 3: Core insight

Aisa problem solve karne ke liye mujhe turant yaad aata hai:

* **Expression parsing** usually hota hai stack se.
* Parentheses matlab:

  * Jab `"("` mile to ab tak ka result aur sign yaad rakh lo → naya subproblem start karo.
  * Jab `")"` mile to subproblem ka result pichle result me jodo.

Matlab mujhe ek aisa **data structure chahiye jo old context save kare → stack**

---

## 🔹 Step 4: Dry run ek example

Expression: `"1 - (2 + 3)"`

* Start: `res = 0, sign = 1, num = 0`
* `'1'` → `num = 1`
* `'-'` → commit number → `res = res + sign*num = 0+1*1 = 1`, `num=0`, sign=-1
* `'('` → push `res=1` and `sign=-1`, reset `res=0`, `sign=1`
* `'2'` → `num=2`
* `'+'` → commit → `res=0+1*2=2`, `num=0`, `sign=1`
* `'3'` → `num=3`
* `')'` → commit `res=2+1*3=5`. Pop `sign=-1`, `resPrev=1`.
  Final res = `resPrev + sign*res = 1 + (-1)*5 = -4`. ✅

👉 Dry run se confirm ho gaya ki stack + sign + res trick kaam karega.

---

## 🔹 Step 5: Translate logic to code

1. Ek loop chalao har char par.
2. Agar digit hai → `num = num*10 + digit`.
3. Agar `+`/`-` hai → `res += sign*num; num=0; sign=+1/-1`.
4. Agar `'('` hai → stack pe `res, sign` push karo, aur fresh start.
5. Agar `')'` hai → current num ko commit karo, phir pop karke combine karo.
6. Loop ke baad bachha hua `num` add karo.

---

## 🔹 Step 6: Complexity socho

* Har character ek hi baar process ho raha hai → `O(n)` time.
* Stack me bas parentheses depth jitna hi data → `O(n)` space worst-case.

---

⚡ **Summary of thinking process:**

1. Question ko breakdown kiya → kya input/output, kya operators, kya constraints.
2. Parentheses dekhe → stack/recursion ka idea aya.
3. Operators dekhe → bas +, - hai → `sign` ka variable kaam karega.
4. Dry run kiya simple example par → logic validate hua.
5. Us logic ko systematic code me convert kar diya.


---
 # Learning Stack:


* **Push** (naya element dalna) → element **top par add hota hai**. Matlab stack ke sabse upar rakha jata hai.
* **Pop** (element nikalna) → hamesha **top se hi nikalta hai**, neeche se nahi.

So, tum agar ek **thaliyon ka stack** socho:

* Nayi thali **sabse upar rakho** (push).
* Thali nikalni hai to bhi **upar wali hi niklegi** (pop).

👉 Isliye Stack ko **LIFO (Last In, First Out)** bola jata hai.
Matlab jo sabse last mein gaya hoga, wahi sabse pehle bahar aayega.

---
 # Stack Ko Or Jano
Bahut accha sawal pucha 👏
Samajhne ki koshish karte hain **stack kya hota hai aur uska use kaise sochte hain.**

---

### 🔹 Stack kya hota hai?

Stack ek **data structure** hai jisme elements ko **Last In, First Out (LIFO)** principle ke hisaab se access karte hain.
Matlab jo sabse last mein dala (push kiya) hoga, wahi sabse pehle niklega (pop hoga).

Example:

* Plates ka stack socho 🍽️

  * Upar wali plate sabse pehle uthti hai.
  * Niche wali plate tabhi milti hai jab upar wali plates nikal chuki hoti hain.

---

### 🔹 Stack kaise use hota hai?

Stack useful hota hai jab tumhe kisi problem mein **reverse order, nested structure, ya intermediate values store** karne ki zarurat ho.

Examples:

1. **Expression evaluation** (infix → postfix, postfix evaluate)
2. **Balanced parentheses check**: `(([]))` valid hai ya nahi.
3. **DFS traversal** graph mein.
4. **Undo/Redo operation**.

---

### 🔹 Mere logic ka flow (jab main stack sochta hoon)

Jab tumne bola ki *"array se ek expression banana hai aur evaluate karna hai"*, tab maine socha:

* Expression evaluation mein sabse common data structure kaunsa use hota hai? → **Stack**.
* Kyun? Kyunki:

  * Operator aur operand ko temporary rakhna padta hai.
  * Jaise hi ek operator aata hai, pichhle do operands nikal ke (pop karke) result banate hain, aur wapas push kar dete hain.

👉 Isi wajah se stack perfect fit hai is problem ke liye.

---


---
 # Stack K commands ko Samjho
Bilkul 👍. Java mein `Stack` ek **class** hai jo `java.util` package mein aati hai, aur yeh **Last In First Out (LIFO)** principle follow karti hai. Matlab jo element sabse last mein insert hua, wahi sabse pehle niklega.

Chalo main tumhe ek **short summary** deta hoon `Stack` ke **common functions / built-ins** ke sath:

---

## 🔹 Import

```java
import java.util.Stack;
```

---

## 🔹 Stack Creation

```java
Stack<Integer> stack = new Stack<>();
```

---

## 🔹 Important Functions (Most Common)

1. **push(E item)** → element stack ke top pe add karega

   ```java
   stack.push(10);   // [10]
   stack.push(20);   // [10, 20]
   ```

2. **pop()** → top element hata dega aur return karega

   ```java
   int removed = stack.pop();   // removed = 20, stack = [10]
   ```

3. **peek()** → sirf top element dekhne ke liye (remove nahi karega)

   ```java
   int top = stack.peek();   // top = 10, stack = [10]
   ```

4. **isEmpty()** → check karta hai stack khali hai ya nahi

   ```java
   if(stack.isEmpty()) {
       System.out.println("Stack is empty");
   }
   ```

5. **size()** → kitne elements hai stack mein

   ```java
   System.out.println(stack.size());  // e.g., 1
   ```

6. **search(Object o)** → kisi element ka **1-based position** batata hai top se

   ```java
   stack.push(30);  // [10, 30]
   System.out.println(stack.search(10)); // 2 (10 top se dusre number pe hai)
   ```

---

## 🔹 Example Program

```java
import java.util.*;

class Main {
    public static void main(String[] args) {
        Stack<Integer> stack = new Stack<>();

        // Push elements
        stack.push(10);
        stack.push(20);
        stack.push(30);
        System.out.println("Stack: " + stack);

        // Peek
        System.out.println("Top element: " + stack.peek());

        // Pop
        System.out.println("Popped: " + stack.pop());
        System.out.println("Stack after pop: " + stack);

        // Size
        System.out.println("Size: " + stack.size());

        // Search
        System.out.println("Position of 10 from top: " + stack.search(10));

        // Empty check
        System.out.println("Is empty? " + stack.isEmpty());
    }
}
```

---

👉 Output:

```
Stack: [10, 20, 30]
Top element: 30
Popped: 30
Stack after pop: [10, 20]
Size: 2
Position of 10 from top: 2
Is empty? false
```

Bilkul 👍 tu chaahta hai ki **Stack** ke saare important built-in functions / methods jo Java mein frequently use hote hain unka ekdum clear aur short reference mil jaye. Main tujhe `java.util.Stack` ke saare commonly used methods aur kuch extra related cheezein ek hi jagah de deta hoon.

---

## 🔹 Import karna

```java
import java.util.Stack;
```

---

## 🔹 Stack Banane ka Tarika

```java
Stack<Integer> stack = new Stack<>();
```

---

## 🔹 Important & Commonly Used Methods

### 1. **push(E item)**

Stack mein element dalta hai (TOP par).

```java
stack.push(10);
stack.push(20);
```

👉 Stack = \[10, 20]

---

### 2. **pop()**

Top element remove karta hai **aur return bhi karta hai**.

```java
int val = stack.pop();  // val = 20
```

👉 Stack = \[10]

---

### 3. **peek()**

Top element ko sirf **dekhta hai** (remove nahi karta).

```java
int top = stack.peek();  // top = 10
```

---

### 4. **empty()**

Check karta hai ki stack khali hai ya nahi.

```java
boolean check = stack.empty(); // false
```

---

### 5. **search(Object o)**

Stack mein element ki position (1-based from TOP) return karta hai.

```java
int pos = stack.search(10); // 1 (because 10 is at top)
```

👉 Agar na mile to `-1`.

---

## 🔹 Other Useful Methods (Inherited from Vector)

Java ka `Stack` class actually **Vector** se inherit karta hai. Matlab uske saath Vector ke methods bhi milte hain. Kuch kaam ke:

### 6. **size()**

```java
int s = stack.size();  
```

### 7. **isEmpty()**

```java
boolean b = stack.isEmpty();  
```

### 8. **get(int index)**

Index se element nikalna (Vector method hai, stack ke liye generally use nahi karte).

```java
int val = stack.get(0);
```

### 9. **clear()**

Poore stack ko empty karna.

```java
stack.clear();
```

### 10. **contains(Object o)**

Check karta hai ki stack mein element present hai ya nahi.

```java
boolean c = stack.contains(10);
```

### 11. **iterator()**

Loop chalane ke liye use hota hai.

```java
for(Integer i : stack){
    System.out.println(i);
}
```

---

## 🔹 Example Code (All in One)

```java
import java.util.Stack;

public class Main {
    public static void main(String[] args) {
        Stack<Integer> stack = new Stack<>();

        // Push
        stack.push(10);
        stack.push(20);
        stack.push(30);

        System.out.println("Stack: " + stack); // [10, 20, 30]

        // Peek
        System.out.println("Top: " + stack.peek()); // 30

        // Pop
        System.out.println("Popped: " + stack.pop()); // 30
        System.out.println("After pop: " + stack);    // [10, 20]

        // Size
        System.out.println("Size: " + stack.size()); // 2

        // Search
        System.out.println("Position of 10: " + stack.search(10)); // 2

        // Empty check
        System.out.println("Empty? " + stack.empty()); // false

        // Contains
        System.out.println("Contains 20? " + stack.contains(20)); // true

        // Clear
        stack.clear();
        System.out.println("After clear: " + stack); // []
    }
}
```

---

⚡ Soch stack ke methods mein **sabse important** hain:

* `push()`
* `pop()`
* `peek()`
* `empty()` / `isEmpty()`
* `search()`

Baaki `size()`, `clear()`, `contains()` extra help ke liye hote hain.

---

👉 Ab bata, kya tujhe chahiye ki main stack ke **DSA wale problems** bhi list karu (jaise balanced parentheses, next greater element, infix to postfix), jisme ye functions direct use hote hain?

---
 # The soln
```java
class Solution {
    public int calculate(String s) {
        int n = s.length();
        int res = 0;        // current result
        int num = 0;        // current number being built
        int sign = 1;       // +1 or -1
        java.util.Deque<Integer> st = new java.util.ArrayDeque<>();

        for (int i = 0; i < n; i++) {
            char c = s.charAt(i);

            if (c >= '0' && c <= '9') {
                // build multi-digit number
                num = num * 10 + (c - '0'); 
                // Example: agar '1' fir '2' aaye to num = 1 → num = 1*10 + 2 = 12.
                /* String s = "1";
                num = 0 * 10 + ('1' - '0')
    = 0 + (49 - 48)   // ASCII difference
    = 1
*/

            } else if (c == '+') {
                // commit the previous number with its sign
                res += sign * num;
                num = 0;
                sign = 1;
            } else if (c == '-') {
                res += sign * num;
                num = 0;
                sign = -1;
                // Phir: num reset karo aur next number ke liye sign = +1 set karo.

// Kyoon: operator pe aane ka matlab pehla number khatam ho gaya — ab next number sign ke hisaab se add hoga.
            } else if (c == '(') {
                // push current context
                st.push(res);
                st.push(sign);
                // reset for subexpression
               // Note: Order push ka important point — pehle res push kiya, phir sign. Isliye jab pop karenge to prevSign = st.pop() pehle milega aur prevRes = st.pop() baad me.
                res = 0;
                sign = 1;
            } else if (c == ')') {
                // close current number into res
                res += sign * num;
                num = 0;
                // pull context back
                int prevSign = st.pop();
                int prevRes  = st.pop();
                res = prevRes + prevSign * res;
            } else if (c == ' ') {
                // ignore
            }
        }

        // add any trailing number
        res += sign * num;
        return res;
    }
}


```
---
---
 # FAst soln recursion
```java
class Solution {
    int i = 0; // global pointer

    public int calculate(String s) {
        return helper(s);
    }

    private int helper(String s) {
        int res = 0, num = 0, sign = 1;
        while (i < s.length()) {
            char c = s.charAt(i++);
            if (Character.isDigit(c)) {
                num = num * 10 + (c - '0');
            } else if (c == '+') {
                res += sign * num;
                num = 0;
                sign = 1;
            } else if (c == '-') {
                res += sign * num;
                num = 0;
                sign = -1;
            } else if (c == '(') {
                num = helper(s); // recurse into subexpr
            } else if (c == ')') {
                break; // return to parent
            }
        }
        res += sign * num;
        return res;
    }
}


```
---
---
 # Isi recurssion ka achha version
```java

class Solution {
    int i = 0;
    public int cal(String s)
    {
        int num = 0,result = 0,sign = 1;
        while(i<s.length())
        {
            char ch = s.charAt(i);
            if(ch>='0' && ch<='9')
            {
                num=num*10+(ch - '0');
            }
            else if(ch == '+')
            {
                result = result + (num * sign);
                num = 0;
                sign = 1;
            }
            else if(ch == '-')
            {
                result = result + (num * sign);
                num = 0;
                sign = -1;   
            }
            else if(ch == '(')
            {
                i++;
                int r = cal(s);
                result = result + (r * sign);
                sign = 1;
            }
            else if(ch == ')')
            {
                result = result + (num * sign);
                return result;
            }
            i++;
        }
        result = result + (num * sign);
        return result;
    }
    public int calculate(String s) {

        return cal(s);
        
    }
}
```
---
---
 # Explanation
Nice — this is a neat **recursive** solution for LeetCode 224. I’ll explain **what each part does**, **why it works**, and then do a **detailed step-by-step dry run** on an example. Finally I’ll list edge cases, complexity, and a tiny safety tweak you should apply.

# Quick overview

* The method `cal(String s)` parses `s` left → right using a single global index `i`.
* It builds multi-digit numbers (`num`), accumulates a running `result`, and uses `sign` (`+1` or `-1`) to know whether to add or subtract the current number.
* On `'('` it **recurses** to evaluate the subexpression; on `')'` the recursion returns the subresult to the caller.
* Spaces are implicitly ignored (no branch matches, loop just increments `i`).

# Variables (roles)

* `int i = 0;` — global pointer into the string (shared across recursion).
* `int num` — currently-building number (supports multi-digit: `num = num*10 + digit`).
* `int result` — accumulated value for the current (sub)expression.
* `int sign` — either `+1` or `-1`, meaning how `num` (or a returned subresult) should be applied to `result`.

# Walkthrough of the code logic (branch by branch)

```java
while (i < s.length()) {
    char ch = s.charAt(i);

    if (ch >= '0' && ch <= '9') {
        num = num * 10 + (ch - '0');         // build multi-digit number
    }
    else if (ch == '+') {
        result = result + (num * sign);      // commit the number
        num = 0;
        sign = 1;                            // next numbers are positive unless changed
    }
    else if (ch == '-') {
        result = result + (num * sign);      // commit the number
        num = 0;
        sign = -1;                           // next numbers are negative unless changed
    }
    else if (ch == '(') {
        i++;                                 // move past '('
        int r = cal(s);                      // evaluate subexpression recursively
        result = result + (r * sign);        // apply whole subexpression by the sign
        sign = 1;                            // reset sign for what follows
    }
    else if (ch == ')') {
        result = result + (num * sign);      // commit current num and return subresult
        return result;
    }
    i++;
}
result = result + (num * sign);   // commit any trailing number
return result;
```

**Why these choices?**

* `num*10 + digit` lets you parse multi-digit numbers (not just single characters).
* On `+` or `-` you must **commit** the accumulated `num` into `result` before changing sign.
* On `'('` you evaluate the whole parenthesized expression with recursion; that subresult is treated as a single number and multiplied by the current `sign`.
* On `')'` you return the current subexpression result to the caller (caller will apply its sign).

# Dry run (detailed) — example: `s = "1+(2-(3+4))"`

Indices: `0:'1' 1:'+' 2:'(' 3:'2' 4:'-' 5:'(' 6:'3' 7:'+' 8:'4' 9:')' 10:')'`

Initial: `i=0, num=0, result=0, sign=1`

1. `i=0`, `ch='1'` → digit: `num = 1`. Then `i++ -> 1`.
2. `i=1`, `ch='+'` → commit: `result += 1 * 1 = 1`. `num=0`, `sign=1`. `i++ -> 2`.
3. `i=2`, `ch='('` → `i++ -> 3`, call `cal(s)` recursively (enter subexpression A).

   **subexpr A (i=3):** `num=0,result=0,sign=1`
   4\. `i=3`, `ch='2'` → digit: `num=2`. `i++ -> 4`.
   5\. `i=4`, `ch='-'` → commit: `result += 2 * 1 = 2`. `num=0`, `sign=-1`. `i++ -> 5`.
   6\. `i=5`, `ch='('` → `i++ -> 6`, call `cal(s)` recursively (enter subexpression B).

   **subexpr B (i=6):** `num=0,result=0,sign=1`
   7\. `i=6`, `ch='3'` → digit: `num=3`. `i++ -> 7`.
   8\. `i=7`, `ch='+'` → commit: `result += 3*1 = 3`. `num=0`, `sign=1`. `i++ -> 8`.
   9\. `i=8`, `ch='4'` → digit: `num=4`. `i++ -> 9`.
   10\. `i=9`, `ch=')'` → commit: `result += 4*1 = 7`. Return `7` to caller (subexpr B returns).
   (Note: inner `cal` returns without advancing `i` past `')'`; the caller's loop will `i++` after handling.)
   11\. Back in subexpr A: `r = 7` → apply `result = 2 + (7 * sign)` with `sign = -1` → `result = 2 + (7 * -1) = -5`. `sign = 1`. Then `i++` (the caller increments) -> now `i = 10`.
   12\. `i=10`, `ch=')'` in subexpr A → commit: `result += num*sign` (num=0) → still `-5`. Return `-5` to outer.
4. Back in outer: `r = -5` → apply `result = 1 + (-5 * sign)` (outer sign=1) → `result = 1 - 5 = -4`. `sign = 1`. `i++` → now `i = 11`.
5. Loop ends (`i == s.length()`), commit trailing number (`num=0`). Final `result = -4`.

Final return: `-4` — correct.

# Key correctness points

* **Nested parentheses**: recursion acts like the parser’s call stack; each recursive call computes exactly the value of its parenthesized subexpression and returns it.
* **Unary minus**: leading `-` is handled because when `-` is encountered with `num==0` we set `sign=-1` and next number/subexpression will be applied negatively. Example: `"-2+3"` → correctly `1`.
* **Multi-digit numbers**: building `num` with `num = num*10 + ...` allows `123` to be read properly.
* **Spaces**: implicitly ignored because none of the branches match and `i++` still moves forward.

# Edge cases & small safety tweak

* If the same `Solution` object is reused for multiple `calculate(...)` calls, `i` must be reset to `0` at the start of `calculate`. LeetCode creates a new instance per test, but safer code would be:

```java
public int calculate(String s) {
    i = 0;           // reset index for safety
    return cal(s);
}
```

* This implementation does not handle `*` or `/` (not needed for LC224).
* If numbers could overflow `int` in other contexts, switch to `long` or `BigInteger`.

# Complexity

* **Time:** O(n) — each character is visited at most once (across the recursion).
* **Space:** O(d) recursion stack where d = max parentheses nesting (worst-case O(n)).

# Short summary (TL;DR)

* This recursive solution parses digits, commits numbers on `+`/`-`, and uses recursion to handle parentheses; each returned subresult is multiplied by the active `sign`.
* It’s clean, O(n) time, handles multi-digit numbers, nested parentheses and unary `-`. Just remember to reset `i=0` at `calculate` start for safety.

If you want, I can:

* Convert this to an **iterative** version using an explicit stack, or
* Add a few unit-test examples (and show how it behaves on `"-1"`, `" 2- (3 + 4)"`, nested cases).

---
---
 #
```java


```
---
---
 #
```java


```
---
---
 #
```java


```
---
---
 #
```java


```
---
---
 #
```java


```
---
---
 #
```java


```
---
---
 #
```java


```
---
---
 #
```java


```
---
---
 #
```java


```
---
---
 #
```java


```
---
---
 #
```java


```
---
---
 #
```java


```
---
# leetcode problem 224

***Good one the best one***
---
*** *** 
---

## some important points to leran:

---
 # **`char` to `int`**

---

## ğŸ”¹ 1. Character ka **ASCII / Unicode value** lena

```java
char c = 'A';
int ascii = c;  // automatic conversion
System.out.println(ascii); // 65
```


## ğŸ”¹ 2. Agar digit char ho (e.g. `'5'`) â†’ uska actual number chahiye

```java
char c = '5';
int num = c - '0';
System.out.println(num); // 5
```


## ğŸ”¹ 3. Wrapper class se

```java
char c = '7';
int num = Character.getNumericValue(c);
System.out.println(num); // 7
```


## ğŸ”¹ 4. String bana kar parse karna

```java
char c = '9';
int num = Integer.parseInt(String.valueOf(c));
System.out.println(num); // 9
```

---
 # Soch process


## ğŸ”¹ Step 1: Question samajhna

* Input: ek string expression `"1 + (2 - 3)"`
* Allowed operators: `+`, `-`
* Parentheses `(` `)` allowed
* Digits ho sakte hai multi-digit aur beech me spaces bhi.

ğŸ‘‰ Matlab ye ek **expression evaluation** problem hai. Multiplication/division nahi, sirf plus/minus aur parentheses.

---

## ğŸ”¹ Step 2: Observe constraints

* `+` aur `-` ke alawa kuch nahi â†’ simple hai.
* Parentheses hain â†’ iska matlab recursion ya stack use hoga.
* Digits multi-digit ho sakte hain â†’ number build karna padega (`num = num*10 + digit`).
* Spaces ignore karne honge.

---

## ğŸ”¹ Step 3: Core insight

Aisa problem solve karne ke liye mujhe turant yaad aata hai:

* **Expression parsing** usually hota hai stack se.
* Parentheses matlab:

  * Jab `"("` mile to ab tak ka result aur sign yaad rakh lo â†’ naya subproblem start karo.
  * Jab `")"` mile to subproblem ka result pichle result me jodo.

Matlab mujhe ek aisa **data structure chahiye jo old context save kare â†’ stack**

---

## ğŸ”¹ Step 4: Dry run ek example

Expression: `"1 - (2 + 3)"`

* Start: `res = 0, sign = 1, num = 0`
* `'1'` â†’ `num = 1`
* `'-'` â†’ commit number â†’ `res = res + sign*num = 0+1*1 = 1`, `num=0`, sign=-1
* `'('` â†’ push `res=1` and `sign=-1`, reset `res=0`, `sign=1`
* `'2'` â†’ `num=2`
* `'+'` â†’ commit â†’ `res=0+1*2=2`, `num=0`, `sign=1`
* `'3'` â†’ `num=3`
* `')'` â†’ commit `res=2+1*3=5`. Pop `sign=-1`, `resPrev=1`.
  Final res = `resPrev + sign*res = 1 + (-1)*5 = -4`. âœ…

ğŸ‘‰ Dry run se confirm ho gaya ki stack + sign + res trick kaam karega.

---

## ğŸ”¹ Step 5: Translate logic to code

1. Ek loop chalao har char par.
2. Agar digit hai â†’ `num = num*10 + digit`.
3. Agar `+`/`-` hai â†’ `res += sign*num; num=0; sign=+1/-1`.
4. Agar `'('` hai â†’ stack pe `res, sign` push karo, aur fresh start.
5. Agar `')'` hai â†’ current num ko commit karo, phir pop karke combine karo.
6. Loop ke baad bachha hua `num` add karo.

---

## ğŸ”¹ Step 6: Complexity socho

* Har character ek hi baar process ho raha hai â†’ `O(n)` time.
* Stack me bas parentheses depth jitna hi data â†’ `O(n)` space worst-case.

---

âš¡ **Summary of thinking process:**

1. Question ko breakdown kiya â†’ kya input/output, kya operators, kya constraints.
2. Parentheses dekhe â†’ stack/recursion ka idea aya.
3. Operators dekhe â†’ bas +, - hai â†’ `sign` ka variable kaam karega.
4. Dry run kiya simple example par â†’ logic validate hua.
5. Us logic ko systematic code me convert kar diya.


---
 # Learning Stack:


* **Push** (naya element dalna) â†’ element **top par add hota hai**. Matlab stack ke sabse upar rakha jata hai.
* **Pop** (element nikalna) â†’ hamesha **top se hi nikalta hai**, neeche se nahi.

So, tum agar ek **thaliyon ka stack** socho:

* Nayi thali **sabse upar rakho** (push).
* Thali nikalni hai to bhi **upar wali hi niklegi** (pop).

ğŸ‘‰ Isliye Stack ko **LIFO (Last In, First Out)** bola jata hai.
Matlab jo sabse last mein gaya hoga, wahi sabse pehle bahar aayega.

---
 # Stack Ko Or Jano
Bahut accha sawal pucha ğŸ‘
Samajhne ki koshish karte hain **stack kya hota hai aur uska use kaise sochte hain.**

---

### ğŸ”¹ Stack kya hota hai?

Stack ek **data structure** hai jisme elements ko **Last In, First Out (LIFO)** principle ke hisaab se access karte hain.
Matlab jo sabse last mein dala (push kiya) hoga, wahi sabse pehle niklega (pop hoga).

Example:

* Plates ka stack socho ğŸ½ï¸

  * Upar wali plate sabse pehle uthti hai.
  * Niche wali plate tabhi milti hai jab upar wali plates nikal chuki hoti hain.

---

### ğŸ”¹ Stack kaise use hota hai?

Stack useful hota hai jab tumhe kisi problem mein **reverse order, nested structure, ya intermediate values store** karne ki zarurat ho.

Examples:

1. **Expression evaluation** (infix â†’ postfix, postfix evaluate)
2. **Balanced parentheses check**: `(([]))` valid hai ya nahi.
3. **DFS traversal** graph mein.
4. **Undo/Redo operation**.

---

### ğŸ”¹ Mere logic ka flow (jab main stack sochta hoon)

Jab tumne bola ki *"array se ek expression banana hai aur evaluate karna hai"*, tab maine socha:

* Expression evaluation mein sabse common data structure kaunsa use hota hai? â†’ **Stack**.
* Kyun? Kyunki:

  * Operator aur operand ko temporary rakhna padta hai.
  * Jaise hi ek operator aata hai, pichhle do operands nikal ke (pop karke) result banate hain, aur wapas push kar dete hain.

ğŸ‘‰ Isi wajah se stack perfect fit hai is problem ke liye.

---


---
 # Stack K commands ko Samjho
Bilkul ğŸ‘. Java mein `Stack` ek **class** hai jo `java.util` package mein aati hai, aur yeh **Last In First Out (LIFO)** principle follow karti hai. Matlab jo element sabse last mein insert hua, wahi sabse pehle niklega.

Chalo main tumhe ek **short summary** deta hoon `Stack` ke **common functions / built-ins** ke sath:

---

## ğŸ”¹ Import

```java
import java.util.Stack;
```

---

## ğŸ”¹ Stack Creation

```java
Stack<Integer> stack = new Stack<>();
```

---

## ğŸ”¹ Important Functions (Most Common)

1. **push(E item)** â†’ element stack ke top pe add karega

   ```java
   stack.push(10);   // [10]
   stack.push(20);   // [10, 20]
   ```

2. **pop()** â†’ top element hata dega aur return karega

   ```java
   int removed = stack.pop();   // removed = 20, stack = [10]
   ```

3. **peek()** â†’ sirf top element dekhne ke liye (remove nahi karega)

   ```java
   int top = stack.peek();   // top = 10, stack = [10]
   ```

4. **isEmpty()** â†’ check karta hai stack khali hai ya nahi

   ```java
   if(stack.isEmpty()) {
       System.out.println("Stack is empty");
   }
   ```

5. **size()** â†’ kitne elements hai stack mein

   ```java
   System.out.println(stack.size());  // e.g., 1
   ```

6. **search(Object o)** â†’ kisi element ka **1-based position** batata hai top se

   ```java
   stack.push(30);  // [10, 30]
   System.out.println(stack.search(10)); // 2 (10 top se dusre number pe hai)
   ```

---

## ğŸ”¹ Example Program

```java
import java.util.*;

class Main {
    public static void main(String[] args) {
        Stack<Integer> stack = new Stack<>();

        // Push elements
        stack.push(10);
        stack.push(20);
        stack.push(30);
        System.out.println("Stack: " + stack);

        // Peek
        System.out.println("Top element: " + stack.peek());

        // Pop
        System.out.println("Popped: " + stack.pop());
        System.out.println("Stack after pop: " + stack);

        // Size
        System.out.println("Size: " + stack.size());

        // Search
        System.out.println("Position of 10 from top: " + stack.search(10));

        // Empty check
        System.out.println("Is empty? " + stack.isEmpty());
    }
}
```

---

ğŸ‘‰ Output:

```
Stack: [10, 20, 30]
Top element: 30
Popped: 30
Stack after pop: [10, 20]
Size: 2
Position of 10 from top: 2
Is empty? false
```

Bilkul ğŸ‘ tu chaahta hai ki **Stack** ke saare important built-in functions / methods jo Java mein frequently use hote hain unka ekdum clear aur short reference mil jaye. Main tujhe `java.util.Stack` ke saare commonly used methods aur kuch extra related cheezein ek hi jagah de deta hoon.

---

## ğŸ”¹ Import karna

```java
import java.util.Stack;
```

---

## ğŸ”¹ Stack Banane ka Tarika

```java
Stack<Integer> stack = new Stack<>();
```

---

## ğŸ”¹ Important & Commonly Used Methods

### 1. **push(E item)**

Stack mein element dalta hai (TOP par).

```java
stack.push(10);
stack.push(20);
```

ğŸ‘‰ Stack = \[10, 20]

---

### 2. **pop()**

Top element remove karta hai **aur return bhi karta hai**.

```java
int val = stack.pop();  // val = 20
```

ğŸ‘‰ Stack = \[10]

---

### 3. **peek()**

Top element ko sirf **dekhta hai** (remove nahi karta).

```java
int top = stack.peek();  // top = 10
```

---

### 4. **empty()**

Check karta hai ki stack khali hai ya nahi.

```java
boolean check = stack.empty(); // false
```

---

### 5. **search(Object o)**

Stack mein element ki position (1-based from TOP) return karta hai.

```java
int pos = stack.search(10); // 1 (because 10 is at top)
```

ğŸ‘‰ Agar na mile to `-1`.

---

## ğŸ”¹ Other Useful Methods (Inherited from Vector)

Java ka `Stack` class actually **Vector** se inherit karta hai. Matlab uske saath Vector ke methods bhi milte hain. Kuch kaam ke:

### 6. **size()**

```java
int s = stack.size();  
```

### 7. **isEmpty()**

```java
boolean b = stack.isEmpty();  
```

### 8. **get(int index)**

Index se element nikalna (Vector method hai, stack ke liye generally use nahi karte).

```java
int val = stack.get(0);
```

### 9. **clear()**

Poore stack ko empty karna.

```java
stack.clear();
```

### 10. **contains(Object o)**

Check karta hai ki stack mein element present hai ya nahi.

```java
boolean c = stack.contains(10);
```

### 11. **iterator()**

Loop chalane ke liye use hota hai.

```java
for(Integer i : stack){
    System.out.println(i);
}
```

---

## ğŸ”¹ Example Code (All in One)

```java
import java.util.Stack;

public class Main {
    public static void main(String[] args) {
        Stack<Integer> stack = new Stack<>();

        // Push
        stack.push(10);
        stack.push(20);
        stack.push(30);

        System.out.println("Stack: " + stack); // [10, 20, 30]

        // Peek
        System.out.println("Top: " + stack.peek()); // 30

        // Pop
        System.out.println("Popped: " + stack.pop()); // 30
        System.out.println("After pop: " + stack);    // [10, 20]

        // Size
        System.out.println("Size: " + stack.size()); // 2

        // Search
        System.out.println("Position of 10: " + stack.search(10)); // 2

        // Empty check
        System.out.println("Empty? " + stack.empty()); // false

        // Contains
        System.out.println("Contains 20? " + stack.contains(20)); // true

        // Clear
        stack.clear();
        System.out.println("After clear: " + stack); // []
    }
}
```

---

âš¡ Soch stack ke methods mein **sabse important** hain:

* `push()`
* `pop()`
* `peek()`
* `empty()` / `isEmpty()`
* `search()`

Baaki `size()`, `clear()`, `contains()` extra help ke liye hote hain.

---

ğŸ‘‰ Ab bata, kya tujhe chahiye ki main stack ke **DSA wale problems** bhi list karu (jaise balanced parentheses, next greater element, infix to postfix), jisme ye functions direct use hote hain?

---
 # The soln
```java
class Solution {
    public int calculate(String s) {
        int n = s.length();
        int res = 0;        // current result
        int num = 0;        // current number being built
        int sign = 1;       // +1 or -1
        java.util.Deque<Integer> st = new java.util.ArrayDeque<>();

        for (int i = 0; i < n; i++) {
            char c = s.charAt(i);

            if (c >= '0' && c <= '9') {
                // build multi-digit number
                num = num * 10 + (c - '0'); 
                // Example: agar '1' fir '2' aaye to num = 1 â†’ num = 1*10 + 2 = 12.
                /* String s = "1";
                num = 0 * 10 + ('1' - '0')
    = 0 + (49 - 48)   // ASCII difference
    = 1
*/

            } else if (c == '+') {
                // commit the previous number with its sign
                res += sign * num;
                num = 0;
                sign = 1;
            } else if (c == '-') {
                res += sign * num;
                num = 0;
                sign = -1;
                // Phir: num reset karo aur next number ke liye sign = +1 set karo.

// Kyoon: operator pe aane ka matlab pehla number khatam ho gaya â€” ab next number sign ke hisaab se add hoga.
            } else if (c == '(') {
                // push current context
                st.push(res);
                st.push(sign);
                // reset for subexpression
               // Note: Order push ka important point â€” pehle res push kiya, phir sign. Isliye jab pop karenge to prevSign = st.pop() pehle milega aur prevRes = st.pop() baad me.
                res = 0;
                sign = 1;
            } else if (c == ')') {
                // close current number into res
                res += sign * num;
                num = 0;
                // pull context back
                int prevSign = st.pop();
                int prevRes  = st.pop();
                res = prevRes + prevSign * res;
            } else if (c == ' ') {
                // ignore
            }
        }

        // add any trailing number
        res += sign * num;
        return res;
    }
}


```
---
---
 # FAst soln recursion
```java
class Solution {
    int i = 0; // global pointer

    public int calculate(String s) {
        return helper(s);
    }

    private int helper(String s) {
        int res = 0, num = 0, sign = 1;
        while (i < s.length()) {
            char c = s.charAt(i++);
            if (Character.isDigit(c)) {
                num = num * 10 + (c - '0');
            } else if (c == '+') {
                res += sign * num;
                num = 0;
                sign = 1;
            } else if (c == '-') {
                res += sign * num;
                num = 0;
                sign = -1;
            } else if (c == '(') {
                num = helper(s); // recurse into subexpr
            } else if (c == ')') {
                break; // return to parent
            }
        }
        res += sign * num;
        return res;
    }
}


```
---
---
 # Isi recurssion ka achha version
```java

class Solution {
    int i = 0;
    public int cal(String s)
    {
        int num = 0,result = 0,sign = 1;
        while(i<s.length())
        {
            char ch = s.charAt(i);
            if(ch>='0' && ch<='9')
            {
                num=num*10+(ch - '0');
            }
            else if(ch == '+')
            {
                result = result + (num * sign);
                num = 0;
                sign = 1;
            }
            else if(ch == '-')
            {
                result = result + (num * sign);
                num = 0;
                sign = -1;   
            }
            else if(ch == '(')
            {
                i++;
                int r = cal(s);
                result = result + (r * sign);
                sign = 1;
            }
            else if(ch == ')')
            {
                result = result + (num * sign);
                return result;
            }
            i++;
        }
        result = result + (num * sign);
        return result;
    }
    public int calculate(String s) {

        return cal(s);
        
    }
}
```
---
---
 # Explanation
Nice â€” this is a neat **recursive** solution for LeetCode 224. Iâ€™ll explain **what each part does**, **why it works**, and then do a **detailed step-by-step dry run** on an example. Finally Iâ€™ll list edge cases, complexity, and a tiny safety tweak you should apply.

# Quick overview

* The method `cal(String s)` parses `s` left â†’ right using a single global index `i`.
* It builds multi-digit numbers (`num`), accumulates a running `result`, and uses `sign` (`+1` or `-1`) to know whether to add or subtract the current number.
* On `'('` it **recurses** to evaluate the subexpression; on `')'` the recursion returns the subresult to the caller.
* Spaces are implicitly ignored (no branch matches, loop just increments `i`).

# Variables (roles)

* `int i = 0;` â€” global pointer into the string (shared across recursion).
* `int num` â€” currently-building number (supports multi-digit: `num = num*10 + digit`).
* `int result` â€” accumulated value for the current (sub)expression.
* `int sign` â€” either `+1` or `-1`, meaning how `num` (or a returned subresult) should be applied to `result`.

# Walkthrough of the code logic (branch by branch)

```java
while (i < s.length()) {
    char ch = s.charAt(i);

    if (ch >= '0' && ch <= '9') {
        num = num * 10 + (ch - '0');         // build multi-digit number
    }
    else if (ch == '+') {
        result = result + (num * sign);      // commit the number
        num = 0;
        sign = 1;                            // next numbers are positive unless changed
    }
    else if (ch == '-') {
        result = result + (num * sign);      // commit the number
        num = 0;
        sign = -1;                           // next numbers are negative unless changed
    }
    else if (ch == '(') {
        i++;                                 // move past '('
        int r = cal(s);                      // evaluate subexpression recursively
        result = result + (r * sign);        // apply whole subexpression by the sign
        sign = 1;                            // reset sign for what follows
    }
    else if (ch == ')') {
        result = result + (num * sign);      // commit current num and return subresult
        return result;
    }
    i++;
}
result = result + (num * sign);   // commit any trailing number
return result;
```

**Why these choices?**

* `num*10 + digit` lets you parse multi-digit numbers (not just single characters).
* On `+` or `-` you must **commit** the accumulated `num` into `result` before changing sign.
* On `'('` you evaluate the whole parenthesized expression with recursion; that subresult is treated as a single number and multiplied by the current `sign`.
* On `')'` you return the current subexpression result to the caller (caller will apply its sign).

# Dry run (detailed) â€” example: `s = "1+(2-(3+4))"`

Indices: `0:'1' 1:'+' 2:'(' 3:'2' 4:'-' 5:'(' 6:'3' 7:'+' 8:'4' 9:')' 10:')'`

Initial: `i=0, num=0, result=0, sign=1`

1. `i=0`, `ch='1'` â†’ digit: `num = 1`. Then `i++ -> 1`.
2. `i=1`, `ch='+'` â†’ commit: `result += 1 * 1 = 1`. `num=0`, `sign=1`. `i++ -> 2`.
3. `i=2`, `ch='('` â†’ `i++ -> 3`, call `cal(s)` recursively (enter subexpression A).

   **subexpr A (i=3):** `num=0,result=0,sign=1`
   4\. `i=3`, `ch='2'` â†’ digit: `num=2`. `i++ -> 4`.
   5\. `i=4`, `ch='-'` â†’ commit: `result += 2 * 1 = 2`. `num=0`, `sign=-1`. `i++ -> 5`.
   6\. `i=5`, `ch='('` â†’ `i++ -> 6`, call `cal(s)` recursively (enter subexpression B).

   **subexpr B (i=6):** `num=0,result=0,sign=1`
   7\. `i=6`, `ch='3'` â†’ digit: `num=3`. `i++ -> 7`.
   8\. `i=7`, `ch='+'` â†’ commit: `result += 3*1 = 3`. `num=0`, `sign=1`. `i++ -> 8`.
   9\. `i=8`, `ch='4'` â†’ digit: `num=4`. `i++ -> 9`.
   10\. `i=9`, `ch=')'` â†’ commit: `result += 4*1 = 7`. Return `7` to caller (subexpr B returns).
   (Note: inner `cal` returns without advancing `i` past `')'`; the caller's loop will `i++` after handling.)
   11\. Back in subexpr A: `r = 7` â†’ apply `result = 2 + (7 * sign)` with `sign = -1` â†’ `result = 2 + (7 * -1) = -5`. `sign = 1`. Then `i++` (the caller increments) -> now `i = 10`.
   12\. `i=10`, `ch=')'` in subexpr A â†’ commit: `result += num*sign` (num=0) â†’ still `-5`. Return `-5` to outer.
4. Back in outer: `r = -5` â†’ apply `result = 1 + (-5 * sign)` (outer sign=1) â†’ `result = 1 - 5 = -4`. `sign = 1`. `i++` â†’ now `i = 11`.
5. Loop ends (`i == s.length()`), commit trailing number (`num=0`). Final `result = -4`.

Final return: `-4` â€” correct.

# Key correctness points

* **Nested parentheses**: recursion acts like the parserâ€™s call stack; each recursive call computes exactly the value of its parenthesized subexpression and returns it.
* **Unary minus**: leading `-` is handled because when `-` is encountered with `num==0` we set `sign=-1` and next number/subexpression will be applied negatively. Example: `"-2+3"` â†’ correctly `1`.
* **Multi-digit numbers**: building `num` with `num = num*10 + ...` allows `123` to be read properly.
* **Spaces**: implicitly ignored because none of the branches match and `i++` still moves forward.

# Edge cases & small safety tweak

* If the same `Solution` object is reused for multiple `calculate(...)` calls, `i` must be reset to `0` at the start of `calculate`. LeetCode creates a new instance per test, but safer code would be:

```java
public int calculate(String s) {
    i = 0;           // reset index for safety
    return cal(s);
}
```

* This implementation does not handle `*` or `/` (not needed for LC224).
* If numbers could overflow `int` in other contexts, switch to `long` or `BigInteger`.

# Complexity

* **Time:** O(n) â€” each character is visited at most once (across the recursion).
* **Space:** O(d) recursion stack where d = max parentheses nesting (worst-case O(n)).

# Short summary (TL;DR)

* This recursive solution parses digits, commits numbers on `+`/`-`, and uses recursion to handle parentheses; each returned subresult is multiplied by the active `sign`.
* Itâ€™s clean, O(n) time, handles multi-digit numbers, nested parentheses and unary `-`. Just remember to reset `i=0` at `calculate` start for safety.

If you want, I can:

* Convert this to an **iterative** version using an explicit stack, or
* Add a few unit-test examples (and show how it behaves on `"-1"`, `" 2- (3 + 4)"`, nested cases).

---
---
 #
```java


```
---
---
 #
```java


```
---
---
 #
```java


```
---
---
 #
```java


```
---
---
 #
```java


```
---
---
 #
```java


```
---
---
 #
```java


```
---
---
 #
```java


```
---
---
 #
```java


```
---
---
 #
```java


```
---
---
 #
```java


```
---
---
 #
```java


```
---
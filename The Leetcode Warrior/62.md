# leetcode problem 

***8***
---
*** *** 
---

## some important points to leran:

---
 # My soln
```java
class Solution {
    public int uniquePaths(int m, int n){
    return (int)(combination(m+n-2, m-1));
}

public long combination(int n, int r){
    long res = 1;
    for(int i=1;i<=r;i++){
        res = res * (n - r + i) / i;
    }
    return res;
}
}

// big integer bhi use kr sakte if int and long can overflow
```
---
---
 # by dynamic programming
```java

class Solution {
    public int uniquePaths(int m, int n){int[][] dp = new int[m][n];
for(int i=0;i<m;i++) dp[i][0]=1;
for(int j=0;j<n;j++) dp[0][j]=1;
for(int i=1;i<m;i++){
    for(int j=1;j<n;j++){
        dp[i][j] = dp[i-1][j] + dp[i][j-1];
    }
}
return dp[m-1][n-1];

}
}
```
---
---
 # dynamic programming 2 soln
```java

class Solution {
    public int uniquePaths(int m, int n) {
        int[][] dp = new int[m][n];
        for(int[] row: dp) Arrays.fill(row,-1);
        int result = countWay(m,n,dp);
        return result;
    }
    public int countWay(int m , int n , int[][] dp){
        for(int i = 0 ; i<m;i++){
            for(int j = 0; j<n;j++){
                if(i==0 && j == 0){
                    dp[i][j] = 1;
                    continue;
                }
                int up = 0;
                int left = 0;
                if(i>0) up = dp[i-1][j];
                if(j>0) left = dp[i][j-1];
                dp[i][j] = up + left;
            }
        }
        return dp[m-1][n-1];
    }
}
```
---
---
 #
```java


```
---
---
 #
```java


```
---
---
 #
```java


```
---
---
 #
```java


```
---
---
 #
```java


```
---
---
 #
```java


```
---
---
 #
```java


```
---
---
 #
```java


```
---
---
 #
```java


```
---
---
 #
```java


```
---
---
 #
```java


```
---
---
 #
```java


```
---
---
 #
```java


```
---
---
 #
```java


```
---
---
 #
```java


```
---
---
 #
```java


```
---
---
 #
```java


```
---
---
 #
```java


```
---
# leetcode problem 342

***phaltu hi samjho***
---
*** *** 
---

## some important points to leran:

---
```Java
1. n<=0 k liye no check for any power wagera
```
---
---

2.
A number is a **power of four** if:

* It‚Äôs positive.
* It‚Äôs also a **power of two** (only one bit set in binary).
* And that **one bit** is at an **odd position** in binary (counting from LSB starting at position 1).

Example:

```
1   -> 0001   (4^0) ‚úÖ  
4   -> 0100   (4^1) ‚úÖ  
16  -> 0001 0000 (4^2) ‚úÖ  
8   -> 1000   ‚ùå  (power of 2 but not power of 4)
```

---


```java
if ((n & (n - 1)) != 0) return false;
```

* This checks if `n` is a **power of two**.

---

```java
return (n & 0x55555555) != 0;
```

### **What‚Äôs `0x55555555`?**

* Hex `0x55555555` = Binary:

```
01010101010101010101010101010101
```

* This pattern has `1`s only in **odd positions** (1st, 3rd, 5th, ... if counting from LSB=1).
* Why? Because powers of 4 always have their `1` in an odd position.

---

---
```Java
3. LSB ‚Üí rightmost bit
```
---
---

4. 
-  Odd positions mask ‚Üí `0x55555555`

  ```
  Binary: 01010101 01010101 01010101 01010101
  (position count from LSB: 1,3,5,... par 1 hai)
  ```

* Even positions mask ‚Üí `0xAAAAAAAA`

  ```
  Binary: 10101010 10101010 10101010 10101010
  (position count from LSB: 2,4,6,... par 1 hai)
  ```

**Position counting ka rule:**
LSB (least significant bit) ko position `1` maana jaata hai, uske baad next bit position `2`, phir `3`‚Ä¶ aur aise aage.


---
```
5. Because in binary, a bit can be either unset (0) or set (1) ‚Äî like an ON/OFF switch.
```
- 0 ‚Üí OFF ‚Üí unset bit

- 1 ‚Üí ON ‚Üí set bit

---
---
6. 
## **Second part of condition**

```java
Integer.bitCount(n - 1) % 2 == 0
```

* `Integer.bitCount(x)` counts **number of set bits** in the binary representation of `x`.
* Here, `x = n - 1`.

üí° **Key idea:**
If `n` is a power of 4, `n-1` has an **even number of 1's** in binary.


---
7. # mera soln:
```java
class Solution {
    public boolean isPowerOfFour(int n) {
        int count = 0;
        if(  n<=0)
     {return false;} 
     // Power of 4 kabhi bhi negative ya zero nahi hota
       while (n > 0) {
            if ((n & 1) == 1) { 
              // Ye check karta hai ki current least significant bit (LSB) 1 hai ya nahi.
                count++;
            }

            n = n >> 1; 
            // next bit ko check karne ke liye.
            if ((n & 1) == 1 && n>0) {
                return false;


// Ye ensure karta hai ki agar ek 1 already mil gaya tha, to uske turant baad wala bit 1 nahi hona chahiye.

// Kyunki power of 4 ke binary representation mein sirf ek 1 hota hai aur wo hamesha odd position pe hota hai (0-based indexing).
            }
             if (count == 2) {
                return false;

            }

            n = n >> 1;

        }
        return true;
    }
}
```
---
---

8. powefull soln {optimized}
```java
class Solution {
    public boolean isPowerOfFour(int n) {
        // must be positive
        if (n <= 0) return false;
        
        // check if power of two
        if ((n & (n - 1)) != 0) return false;
        // check karne ke liye ki number power of two hai ya nahi.
// Power of 2 numbers ki binary representation mein sirf ek hi 1 hota hai.
        
        // check if 1-bit is at odd position (power of four)
        return (n & 0x55555555) != 0;
    }
}

```

Bahut accha sawaal üî• ‚Äî ye wali solution **most standard / optimized** hai LeetCode 342 (*Power of Four*) ke liye.
Chalo line by line breakdown karte hain üëá

---

### üîé Code

```java
class Solution {
    public boolean isPowerOfFour(int n) {
        // must be positive
        if (n <= 0) return false;
        
        // check if power of two
        if ((n & (n - 1)) != 0) return false;
        
        // check if 1-bit is at odd position (power of four)
        return (n & 0x55555555) != 0;
    }
}
```


#### 3. `return (n & 0x55555555) != 0;`

Yaha real trick hai üòé

* `0x55555555` ek hexadecimal mask hai.
* Binary form:

  ```
  01010101 01010101 01010101 01010101
  ```
* Matlab isme **sirf odd-numbered bits (0, 2, 4, ‚Ä¶ positions)** set hain.

üëâ Kyun use karte hain?

* Power of 2 hone ka matlab hai ek hi `1` bit set hai.
* Power of 4 hone ke liye, wo `1` hamesha **even index (0, 2, 4, ‚Ä¶)** par hona chahiye.

---

---
# another soln:
``` java
class Solution {
    public boolean isPowerOfFour(int n) {
        if(n<=0) return false;
        if(n==1) return true;
        if(n%4!=0) return false;
        return isPowerOfFour(n/4);
    }
}
```
---
---
# gyaan ki baat 
Bilkul ‚Äî achhe se tod ke samjhata hoon. üß†üëá
Hum specifically line `return (n & 0x55555555) != 0;` kis tarah kaam karti hai, woh samjhenge.

# 1) Context ‚Äî kyun pehle `power of two` check kar chuke hain

Code pehle ye check karta:

```java
if ((n & (n - 1)) != 0) return false;
```

Iska matlab: agar `n` **power of two** nahi hai (yaani uski binary mein ek se zyada `1` bits hain), toh false.
Isliye jab hum mask se AND kar rahe hain, hum assume kar sakte hain: **agar n valid hua toh usme at most ek bit hi set hogi**.

# 2) Kya hai `0x55555555`? (mask ka matlab)

`0x55555555` ek hexadecimal constant hai. Binary mein yeh repeat karta hai:

```
0101 0101 0101 0101 0101 0101 0101 0101
```

Agar hum LSB (least significant bit) ko index 0 maan ke dekhen to is mask mein **odd-numbered nibble nahin**, balki **even bit positions** (0, 2, 4, 6, ...) pe `1` hai.
Simpler: mask ka bit pattern (right ‚Üí left) = ... 0 1 0 1 0 1 0 1
Iska matlab: bit0 = 1, bit1 = 0, bit2 = 1, bit3 = 0, ...

(agar 64-bit long chahiye toh equivalent mask `0x5555555555555555L` hota hai)

# 3) `(n & mask) != 0` ka logic ‚Äî kya check ho raha hai?

* Hum jaante hain `n` ek power of two ‚Äî matlab **sirf ek bit set** hai, kahin pe.
* `n & mask` check karta hai: kya woh *single set bit* mask ke `1` bits ke saath overlap karta hai?

  * Agar overlap hua (result non-zero) ‚Üí set bit mask ke allowed positions (even positions) par hai ‚Üí **power of 4**.
  * Agar overlap zero ‚Üí set bit mask ke `0` positions (odd positions) par hai ‚Üí **power of 2 but not of 4** (jaise 2, 8, 32).

# 4) Examples (short binary dry runs)

* `n = 1` ‚Üí `...0001`
  mask & n = `...0001` ‚Üí non-zero ‚Üí **true** (1 = 4^0)

* `n = 2` ‚Üí `...0010`
  mask & n = `...0000` ‚Üí zero ‚Üí **false** (2 is 2^1, not 4^k)

* `n = 4` ‚Üí `...0100`
  mask & n = `...0100` ‚Üí non-zero ‚Üí **true** (4 = 4^1)

* `n = 8` ‚Üí `...1000`
  mask & n = `...0000` ‚Üí zero ‚Üí **false**

* `n = 16` ‚Üí `...10000`
  mask & n = `...10000` ‚Üí non-zero ‚Üí **true**

# 5) Ek chhota sa visual (8-bit view)

Index:    7 6 5 4 3 2 1 0
Mask:     0 1 0 1 0 1 0 1  (this is 0x55)
Example n=4 (bit2):  0 0 0 0 0 1 0 0
AND ‚Üí                0 0 0 0 0 1 0 0 ‚Üí non-zero ‚Üí OK

# 6) Kyon yeh safe / correct approach hai

* Pehle `n & (n-1) == 0` se ensure hua ke **ek hi bit set** hai.
* Fir mask se ensure hota hai ki wo **set bit even index (0,2,4,...)** mein hai ‚Äî wahi condition for being 4^k.
* Complexity O(1), very fast.

# 7) Chhota note about Java types

* Yeh mask `0x55555555` 32-bit `int` ke liye bana hai.
* Agar `n` long use kar rahe ho, use `0x5555555555555555L`.

---

Agar chaho to main ab isko ek short code-snippet ke saath 3‚Äì4 example calls karke dikhadein (dry run) ya phir arithmetic alternative bhi bata doon (jaise repeatedly divide by 4). Kaunsa chahoge?


Yes üöÄ tumne ekdum sahi socha.
Jaise humne **odd positions mask (0x55555555)** banaya, waise hi **even bit mask** bhi bana sakte hain.

---

### Bit positions recap

Hum bit positions **right se 0 se start** karte hain:

```
... 7 6 5 4 3 2 1 0
```

* **Even positions** ‚Üí 0, 2, 4, 6 ‚Ä¶
* **Odd positions** ‚Üí 1, 3, 5, 7 ‚Ä¶

---

### Odd position mask (used in Power of 4 check)

Hex:

```
0x55555555
```

Binary (32 bits):

```
0101 0101 0101 0101 0101 0101 0101 0101
```

üëâ Isme **even bits = 1**, odd bits = 0.

---

### Even position mask

Hex:

```
0xAAAAAAAA
```

Binary (32 bits):

```
1010 1010 1010 1010 1010 1010 1010 1010
```

üëâ Isme **odd bits = 1**, even bits = 0.

---

### Example check

```java
int n = 8; // 1000 (bit 3 par 1 hai, jo odd position hai)
System.out.println((n & 0xAAAAAAAA) != 0); // true (odd position par 1 hai)

int m = 16; // 10000 (bit 4 par 1 hai, jo even position hai)
System.out.println((m & 0xAAAAAAAA) != 0); // false (odd position par 1 nahi hai)
```

---

‚úÖ **Summary:**

* `0x55555555` ‚Üí even bit mask (positions 0,2,4,6‚Ä¶)
* `0xAAAAAAAA` ‚Üí odd bit mask (positions 1,3,5,7‚Ä¶)

---

Bataun kya tumhe ek **table bana ke** dikhau jisme numbers (1‚Äì32) ka binary aur ye mask apply karke kaun pass hota hai kaun fail, taaki tumhe pura visual clear ho jaye?

---

# leetcode problem 1871

***medium***
---
*** *** 
---

## sProblem statement

Tumhe ek **binary string s** diya gaya hai (sirf `'0'` aur `'1'` hoti hai).

* Tum **index 0** (first character) se start karte ho.
* Tum sirf **'0'** wale positions par land kar sakte ho.
* Tum har jump me **\[minJump, maxJump] range ke andar** karke aage badh sakte ho.

Tumhe check karna hai ki **kya last index (end of string)** tak reach karna possible hai ya nahi.
Return `true` agar possible hai, warna `false`.

---

 # 60% mera soln tle aayega
```java

class Solution {
    public boolean canReach(String s, int minJump, int maxJump) {
        int n = s.length();
        boolean[] visited = new boolean[n];
        return dfs(s, 0, minJump, maxJump, visited);
    }

    private boolean dfs(String s, int pos, int minJump, int maxJump, boolean[] visited) {
        int n = s.length();

        // base case: agar last index par aa gaye
        if (pos == n - 1) return true;

        // mark visited
        visited[pos] = true;

        // har possible jump try karo
        for (int jump = minJump; jump <= maxJump; jump++) {
            int next = pos + jump;
            if (next < n && !visited[next] && s.charAt(next) == '0') {
                if (dfs(s, next, minJump, maxJump, visited)) {
                    return true;
                }
            }
        }

        return false;
    }
}

```
---
---
 # kyu recursion/DFS use nahi kar sakte
### 1. Problem size

* String ka length **10^5** (1 lakh) tak ho sakta hai.
* Har index se tum **\[minJump, maxJump]** range ke andar try karoge.
* Agar minJump=1 aur maxJump=50000 ho, matlab ek hi node se **50,000 possibilities** check karni pad sakti hai 😱.


---

### 2. Recursion ki limitation

* Java stack recursion 10^5 depth tak support nahi karega → **StackOverflowError**.
* Isliye recursion safe nahi hai yahan.

---

### 3. Efficient tarika (BFS + sliding window)

* Hum ek queue/sliding window logic use karte hain taki **har index sirf ek baar process ho**.
* Jaise hi ek index ko process kar liya, usko dubara visit nahi karenge → Time Complexity **O(n)** ho jaati hai.

---


* BFS/sliding window kya karega?

  * Ek hi pass me valid jumps mark karega.
  * Har index ek hi baar check hoga.


---
 # **kab recursion/DFS use karna chahiye aur kab nahi** 



##  Rule 1: **Input size dekhna**

* Agar input size **≤ 10^3** (1000 ke andar) hai → recursion generally safe hai.
* Agar input size **10^4 – 10^5** ya usse zyada hai → recursion risk hai (StackOverflowError + TLE).
  

## 🔑 Rule 2: **Branching factor dekhna**

* DFS me har step par kitne naye calls banenge?
* Agar har index se 1-2 hi choices hai (jaise normal tree DFS) → recursion theek hai.
* Agar har index se **bahut saari choices**  → recursion bahut slow ho jaayega.

---

## 🔑 Rule 3: **Repeated states / Overlapping subproblems**

* Agar same state baar-baar call ho sakti hai → recursion waste karega time.
* Agar tumhe `visited[]` ya `memo[]` lagana pad raha hai, iska matlab recursion heavy ho raha hai.
  👉 Aise case me BFS/DP better hota hai.

---

## 🔑 Rule 4: **Problem ka nature**

* **Tree / graph traversal (limited size)** → recursion DFS fine.
* **Big string/array with long jumps / paths** → recursion DFS avoid, BFS/sliding window/DP use karo.
* **Path existence problems** → BFS jyada natural lagta hai kyunki tum level by level explore karte ho.


---
---
 # code ka khela



* `dp[i] = true` ka matlab: **index `i` reachable hai** (waha land kiya ja sakta hai).
* Hum sirf unhi indices `i` se aage expand karte hain jinke `dp[i] = true` hai.
* `farthest` batata hai ki **ab tak right side me humne maximum kahan tak scan kar liya hai**, taaki same range ko baar-baar loop na karein. Isse complexity O(n) rehti hai.




```java
        if (s.charAt(n - 1) != '0') return false; // last position must be 0
```

```java
        boolean[] dp = new boolean[n];
        dp[0] = true; // starting point
```

* `dp[i]` = kya `i` reachable hai?
* Start humesha index `0` se hota hai, aur constraint ke hisaab se `s[0]` `'0'` hota hi hai. Isliye `dp[0] = true`.

```java
        int farthest = 0;
```

* `farthest` = **ab tak right side me sabse aage ka index jahan tak hum scan kar chuke**.
* Isse hum **duplicate scanning** avoid karte hain. (Sliding window trick)

```java
        for (int i = 0; i < n; i++) {
            if (!dp[i]) continue;
```

* Left-to-right iterate.
* Agar `i` reachable hi nahi (`dp[i]==false`), to usse aage jumps consider karne ka koi fayda nahi → skip.

```java
            // next range [i + minJump, i + maxJump]
            int start = Math.max(i + minJump, farthest + 1);
            int end = Math.min(i + maxJump, n - 1);
```

* Agar tum index `i` par ho, to tum **sirf** `[i+minJump, i+maxJump]` me land kar sakte ho.
* But hum pehle hi `farthest` tak scan kar chuke ho sakte hain.
  Isliye **naya scanning start** hoga `max(i+minJump, farthest+1)` se.
* `end` ko array boundary `n-1` par cap kiya.

```java
            for (int j = start; j <= end; j++) {
                if (s.charAt(j) == '0') {
                    dp[j] = true;
                }
            }
```

* Ab **sirf nayi window** `[start..end]` scan karo.
* Jahan jahan `'0'` mile, waha land allowed hai → `dp[j] = true`.

```java
            farthest = end;
```

* Humne `[start..end]` tak process kar liya, to `farthest` ko aage badha do.
* Important: isse **har index `j` maximum ek hi baar** check hota hai → O(n).

```java
        }

        return dp[n - 1];
    }
}
```

* Loop ke baad agar `dp[last] = true` hua to **end reachable**; warna `false`.
* Unse aage ki **allowed range** me jo `'0'` wale nodes milte hain unhe mark kar dete hain.
* `farthest` ensure karta hai ki **har edge/position ek hi baar consider ho**, jo BFS ki efficiency ke barabar hai.

---

## Dry Run (quick)

`s = "011010", minJump = 2, maxJump = 3`

* `n=6`, `s[5]='0'` ✅ proceed
* `dp = [true, false, false, false, false, false]`, `farthest=0`

`i=0 (dp[0]=true)`

* `start = max(0+2, 0+1)=2`, `end = min(0+3,5)=3` → scan `[2..3]`

  * `s[2]='1'` → skip
  * `s[3]='0'` → `dp[3]=true`
* `farthest=3`

`i=1 (dp[1]=false)` → skip
`i=2 (dp[2]=false)` → skip
`i=3 (dp[3]=true)`

* `start = max(3+2, 3+1)=5`, `end = min(3+3,5)=5` → scan `[5..5]`

  * `s[5]='0'` → `dp[5]=true`
* `farthest=5`

Loop end → `dp[5]=true` ⇒ **true** ✅

---

## Complexity
### Matlab

* Har index ya toh outer loop mein check hota hai (dp[i] true hai ya nahi).

* Ya fir inner loop mein update hota hai (agar s.charAt(j) == '0').

* Dono jagah ek hi character bar-bar scan nahi hota.

* **Time:** O(n) — har index max ek baar `j` loop me aata hai (thanks to `farthest`).
* **Space:** O(n) — `dp` array.

---

---
 #  Approach (Greedy + Linear Scan)
```java

class Solution {
    public boolean canReach(String s, int minJump, int maxJump) {
        int n = s.length();
        if (s.charAt(n - 1) != '0') return false; // last position must be 0

        boolean[] dp = new boolean[n];
        dp[0] = true; // starting point
        int farthest = 0;

        for (int i = 0; i < n; i++) {
            if (!dp[i]) continue;
            
            // next range [i + minJump, i + maxJump]
            int start = Math.max(i + minJump, farthest + 1);
            int end = Math.min(i + maxJump, n - 1);

            for (int j = start; j <= end; j++) {
                if (s.charAt(j) == '0') {
                    dp[j] = true;
                }
            }
            farthest = end;
        }

        return dp[n - 1];
    }
}


```
---
---
 # Another soln 
```java
class Solution { 
      public boolean canReach(String s, int minJ, int maxJ) {
        int n = s.length(), pre = 0;
        boolean[] dp = new boolean[n];
        dp[0] = true;
        for (int i = 1; i < n; ++i) {
            if (i >= minJ && dp[i - minJ])
                pre++;
            if (i > maxJ && dp[i - maxJ - 1])
                pre--;
            dp[i] = pre > 0 && s.charAt(i) == '0';
        }
        return dp[n - 1];
    }
}

```
---
---
 # code ka kehla

### Short intuition (1-line)

`pre` ek sliding-window counter hai jo batata hai **kitne reachable indices** currently **\[i−maxJ .. i−minJ]** window mein hain. Agar `pre > 0` aur `s[i]=='0'` toh `i` reachable hoga.

---

### Code (tumne jo diya) — aur har line ka matlab

```java
class Solution { 
    public boolean canReach(String s, int minJ, int maxJ) {
        int n = s.length(), pre = 0;
```

* `n` = length of string.
* `pre = 0` — yeh counter rakhega kitne `dp[j] == true` hain **current window** mein (jis window se `i` par jump aa sakta hai).

```java
        boolean[] dp = new boolean[n];
        dp[0] = true;
```

* `dp[i]` means: index `i` reachable hai ya nahi.
* `dp[0] = true` because start hamesha index `0` se hota hai (problem ka assumption usually `s[0]=='0'` hota hai).

```java
        for (int i = 1; i < n; ++i) {
```

* Hum `i = 1` se iterate kar rahe. Har `i` pe decide karenge kya `i` reachable hai.

```java
            if (i >= minJ && dp[i - minJ])
                pre++;
```

* Jab `i >= minJ`, toh index `i - minJ` **ab** hamare current window mein **enter** kar raha hai (ye woh rightmost new index hai jo ab allowed source bana).
* Agar woh `dp[i-minJ] == true` hai, toh `pre++` karke count badhao.
* Intuition: window for `i` is `[i-maxJ, i-minJ]`. Jab `i` badhta hai, new index `i-minJ` add hota hai.

```java
            if (i > maxJ && dp[i - maxJ - 1])
                pre--;
```

* Agar `i > maxJ`, toh index `i - maxJ - 1` **window se nikal raha hai** (ye leftmost old index tha).
* Agar woh `dp[...] == true` tha, toh `pre--` karke count ghata do.
* Isse `pre` hamesha exactly represent karega **count of dp\[j]==true** for `j` in `[i-maxJ, i-minJ]`.

```java
            dp[i] = pre > 0 && s.charAt(i) == '0';
```

* Ab `i` reachable tabhi hoga jab:

  1. `pre > 0` → matlab koi reachable `j` exist karta hai jo `i` tak jump kar sakta (koi source in window).
  2. `s.charAt(i) == '0'` → tum sirf `'0'` par land kar sakte ho.
* Dono true hone par `dp[i] = true`.

```java
        }
        return dp[n - 1];
    }
}
```

* Loop ke baad return karo kya last index reachable hua ya nahi (`dp[n-1]`).

---

### Kyon ye sahi kaam karta hai (formal reasoning, short)

* Problem: `i` reachable ho agar koi `j` ho jisme `dp[j] == true` aur `j + minJ <= i <= j + maxJ`.
* Rewriting: `j` must be in `[i - maxJ, i - minJ]`.
* `pre` maintain karta hai exactly kitne `j` in that interval have `dp[j] == true`.
* Isliye `i` reachable ⇔ `pre > 0` AND `s[i] == '0'`.

Sliding window update (increment at `i - minJ`, decrement at `i - maxJ - 1`) ensures `pre` always matches current interval.

---

### Dry run (example) — `s = "011010"`, `minJ = 2`, `maxJ = 3`

Initialize: `n=6`, `pre=0`, `dp = [true, false, false, false, false, false]`

* `i = 1`

  * `i >= 2 ?` no → no `pre++`
  * `i > 3 ?` no → no `pre--`
  * `dp[1] = (pre>0) && s[1]=='0'` → `0 && ...` → `false`
  * `pre=0`, `dp` unchanged

* `i = 2`

  * `i >= 2` yes, check `dp[0]` → `true` → `pre++` → `pre=1`
  * `i > 3 ?` no
  * `dp[2] = (1>0) && s[2]=='0'` → `true && s[2]=='1'` → `false`
  * `dp = [T, F, F, F, F, F]`, `pre=1`

* `i = 3`

  * `i >= 2` yes, check `dp[1]` → false → no change
  * `i > 3 ?` no
  * `dp[3] = (pre>0) && s[3]=='0'` → `1>0 && '0'` → `true` → `dp[3]=true`
  * `dp = [T, F, F, T, F, F]`, `pre=1`

* `i = 4`

  * `i >= 2` yes, check `dp[2]` → false → no change
  * `i > 3` yes, check `dp[4-3-1=0]` → `dp[0]==true` → `pre--` → `pre=0`
  * `dp[4] = pre>0 && s[4]=='0'` → `false`
  * `dp = [T, F, F, T, F, F]`, `pre=0`

* `i = 5`

  * `i >= 2` yes, check `dp[3]` → true → `pre++` → `pre=1`
  * `i > 3` yes, check `dp[5-3-1=1]` → `dp[1]==false` → no decrement
  * `dp[5] = pre>0 && s[5]=='0'` → `true && '0'` → `dp[5]=true`
  * `dp = [T, F, F, T, F, T]`

Result: `dp[5] = true` → last index reachable. (Matches earlier logic)

---

### Complexity

* **Time:** O(n) — har `i` par constant work: at most one increment and one decrement aur `dp` set. No nested repeated scans.
* **Space:** O(n) for `dp[]`. (You can’t easily eliminate `dp` unless you use another structure to remember which old indices were reachable.)

---

### Edge cases / notes

* Code assumes `dp[0] = true`. Problem usually guarantees `s[0]=='0'`. Agar input me `s[0]=='1'` ho toh start impossible — you can guard with `if (s.charAt(0)!='0') return false;`.
* `pre` can be used as a simple integer counter; we never need to know *which* j made it positive — sirf existence matterti hai.
* This is a very neat sliding-window trick — memory O(n), time O(n). It’s cleaner and faster than naive O(n \* (maxJ-minJ)).

---

Agar chaho to main ab is code ko thoda aur comment-heavy form mein likh kar dedu (har line ke saath 1-sentence comment), ya phir tumhara koi custom example leke trace dikhaun. Kaisa chahiye?

---
---
 # Ek or baar
```java

class Solution { 
    public boolean canReach(String s, int minJump, int maxJump) {
        int n = s.length();
        if (minJump == maxJump && minJump !=1 && n % minJump == 0) return false;
        if (!s.contains("1") && (n % minJump == 0 || n % maxJump == 0) && n != minJump) {
            return true;
        }
        if (maxJump+1 <= n && !s.substring(1, maxJump+1).contains("0")) {
            return false;
        }
        if (s.charAt(n-1) != '0') return false;
        if (n == 1) {
            return true;
        }
        for (int i = maxJump; i >= minJump; i--) {
            if (n - 1 - i >= 0 && s.charAt(n - 1 - i) == '0') {
                if (canReach(s.substring(0, n - i), minJump, maxJump)) {
                    return true;
                }
            }
        }
        return false;
    }
}

```
Bhai 👌, tumne ek **recursive solution** uthaya hai is problem ka (`Jump Game VII` type ka).
Main isko step by step samjhata hoon:

---

### 🔹 Problem kya hai?

Tumhe ek string `s` di gayi hai (sirf `'0'` aur `'1'` se bani).

* Tum **index 0** pe start karte ho.
* Tumhe **sirf `'0'` positions pe hi land karna allowed hai**.
* Har jump ka size `minJump` aur `maxJump` ke beech ho sakta hai.
* Goal hai: kya tum `s[n-1]` (last position) tak reach kar sakte ho?

---

### 🔹 Code Explanation

```java
public boolean canReach(String s, int minJump, int maxJump) {
    int n = s.length();
```

👉 String ki length `n` store kar li.

---

```java
if (minJump == maxJump && minJump !=1 && n % minJump == 0) return false;
```

👉 Agar `minJump == maxJump` hai (sirf ek fixed step allowed hai)
aur woh step `1` nahi hai, aur `n` us step se divisible hai → directly `false`.

* Kyunki fixed jump ke saath last index pe land karna possible hi nahi hoga.

---

```java
if (!s.contains("1") && (n % minJump == 0 || n % maxJump == 0) && n != minJump) {
    return true;
}
```

👉 Agar string mein **koi `'1'` hi nahi hai** (sab `'0'` hai)
aur `n` length minJump/maxJump ke multiple mein aa raha hai → matlab direct jump possible hai → `true`.

---

```java
if (maxJump+1 <= n && !s.substring(1, maxJump+1).contains("0")) {
    return false;
}
```

👉 Starting ke `1 → maxJump` tak agar ek bhi `'0'` nahi mila, toh pehle jump ke baad kahin land hi nahi kar paoge → `false`.

---

```java
if (s.charAt(n-1) != '0') return false;
```

👉 Agar **last cell `'1'` hai** toh impossible hai → `false`.

---

```java
if (n == 1) {
    return true;
}
```

👉 Agar string ki length `1` hai aur wo `'0'` hai → directly `true`.

---

### 🔹 Recursive Backtracking Part

```java
for (int i = maxJump; i >= minJump; i--) {
    if (n - 1 - i >= 0 && s.charAt(n - 1 - i) == '0') {
        if (canReach(s.substring(0, n - i), minJump, maxJump)) {
            return true;
        }
    }
}
return false;
```

👉 Ye loop last se reverse check karta hai:

* Last index `n-1` pe reach karne ke liye tumhe kisi position `(n-1-i)` se jump lena hoga jahan `minJump <= i <= maxJump`.
* Agar wo position `'0'` hai, toh recursively check kar lo ki kya `(n-i)` tak pohcha ja sakta hai.
* Agar kahin bhi possible mila → `true`.
* Warna finally → `false`.

---

### 🔹 Problem kya hai is approach mein?

1. **Exponential recursion**: Har step pe tum multiple recursive calls kar rahe ho.

   * Agar string lambi hai (e.g. 10⁵ length), toh TLE ho jayega.

2. **String slicing (`s.substring`)**: Ye har recursive call me `O(n)` copy karta hai → bahut slow.

---

### 🔹 Optimized Approach (DP / BFS)

* Is problem ka **best solution sliding window + BFS/DP** se hota hai.
* Idea: Ek queue rakho jisme reachable indices ho.
* Ek sliding window maintain karo `minJump` aur `maxJump` ke liye.
* Har index ko ek hi bar process karo.
* Complexity: **O(n)**.



---
 #
```java


```
---
---
 #
```java


```
---
---
 #
```java


```
---
---
 #
```java


```
---
---
 #
```java


```
---
---
 #
```java


```
---
---
 #
```java


```
---
---
 #
```java


```
---
---
 #
```java


```
---
---
 #
```java


```
---
---
 #
```java


```
---
---
 #
```java


```
---
---
 #
```java


```
---
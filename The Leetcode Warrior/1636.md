# leetcode problem  1636

***very good one***
---
*** *** 
---

## some important points to leran:

---
```
1.class Solution {
    public int[] frequencySort(int[] nums) {
        // 1⃣ Count frequency with hash map.
        Map<Integer, Integer> freq = new HashMap<>();
        for (int x : nums) freq.put(x, freq.getOrDefault(x, 0) + 1);

        // 2⃣ Sort nums array using custom comparator.
        return Arrays.stream(nums)
            .boxed()
            .sorted((a, b) -> {
                int fa = freq.get(a), fb = freq.get(b);
                if (fa != fb) {
                    // Less frequent first
                    return Integer.compare(fa, fb);
                } else {
                    // If same freq, higher number first
                    return Integer.compare(b, a);
                }
            })
            .mapToInt(i -> i)
            .toArray();
    }
}

```
---
---
```
2. class Solution {
    public int[] frequencySort(int[] nums) {
        int[] freq = new int[201]; // index offset by +100
        for (int num : nums) {
            freq[num + 100]++;
        }

        // Sort using Arrays.sort with comparator
        Integer[] boxed = Arrays.stream(nums).boxed().toArray(Integer[]::new);
        Arrays.sort(boxed, (a, b) -> {
            if (freq[a + 100] != freq[b + 100]) {
                return freq[a + 100] - freq[b + 100]; // increasing freq
            }
            return b - a; // same freq -> larger number first
        });

        return Arrays.stream(boxed).mapToInt(i -> i).toArray();
    }
}

```
---
---
```
3.Bucket Sort Approach (Frequency Buckets)
⚡ Agar tum sort ka O(n log n) cost avoid karna chahte ho, toh frequency ke buckets banake O(n) time me solve kar sakte ho.

class Solution {
    public int[] frequencySort(int[] nums) {
        int[] freq = new int[201];
        for (int num : nums) freq[num + 100]++;

        // Create buckets where index = frequency, value = list of numbers
        List<Integer>[] buckets = new List[nums.length + 1];
        for (int i = 0; i < buckets.length; i++) buckets[i] = new ArrayList<>();

        for (int val = -100; val <= 100; val++) {
            int f = freq[val + 100];
            if (f > 0) buckets[f].add(val);
        }

        // Build result: iterate buckets from low freq to high freq
        int idx = 0;
        int[] res = new int[nums.length];
        for (int f = 1; f < buckets.length; f++) {
            List<Integer> list = buckets[f];
            list.sort((a, b) -> b - a); // larger number first if same freq
            for (int val : list) {
                for (int k = 0; k < f; k++) {
                    res[idx++] = val;
                }
            }
        }
        return res;
    }
}


```
---
---
```
4.  Priority Queue (Heap) Method


class Solution {
    public int[] frequencySort(int[] nums) {
        Map<Integer, Integer> freq = new HashMap<>();
        for (int num : nums) freq.put(num, freq.getOrDefault(num, 0) + 1);

        PriorityQueue<Integer> pq = new PriorityQueue<>(
            (a, b) -> {
                int fa = freq.get(a), fb = freq.get(b);
                if (fa != fb) return fa - fb; // low freq first
                return b - a; // same freq -> larger first
            }
        );
        pq.addAll(freq.keySet());

        int[] res = new int[nums.length];
        int idx = 0;
        while (!pq.isEmpty()) {
            int val = pq.poll();
            for (int i = 0; i < freq.get(val); i++) {
                res[idx++] = val;
            }
        }
        return res;
    }
}


⚡ Min-heap bana ke frequency ke hisaab se order nikal lo.
```
---
---

5. bucket explaination 
-  ```
    bucket[1] → [numbers jo bas 1 baar aaay e hai ]
    bucket[2] → [numbers jo bas 2 baar aaay e hai ]
   ```

  -  0 index ka kya hota hai?
     -   
       ```
         Frequency 0 ka matlab: koi bhi number aisa nahi hai jo 0 baar aaya ho


         Isliye bucket[0] hamesha empty hota hai, use hum kabhi fill nahi karte.
        ```
---
---

6. two option two form a buckets
```
int n = nums.length;

// 1) Har frequency ke liye ek list ka bucket
List<Integer>[] buckets = new List[n + 1];

// 2) Har bucket ko initialize zaroor karo (warna NullPointerException)
for (int i = 0; i <= n; i++) {
    buckets[i] = new ArrayList<>();
}

```
```

int n = nums.length;

// Array ki jagah ek list of lists
List<List<Integer>> buckets = new ArrayList<>(n + 1);

// 0..n tak empty lists daal do
for (int i = 0; i <= n; i++) {
    buckets.add(new ArrayList<>());
}

```
---
---
```
7. nth bucket  contains elements which comes for nth times  and har bucjet k andr sorting hogi and bucket to sort h hi frequency k hisab se 

```
---
---

8. Sorting buckets
```
for (int i = 1; i <= n; i++) {
    if (!buckets[i].isEmpty()) {
        Collections.sort(buckets[i]);  // ascending sort
    }
}
```

Agar tumhe descending chahiye:
```

Collections.sort(buckets[i], Collections.reverseOrder());
```
---

---
```
9. List<Integer> result = new ArrayList<>();

for (int freq = 1; freq <= n; freq++) {   // chhoti frequency se badi tak
    for (int val : buckets[freq]) {       // har bucket ka number
        for (int k = 0; k < freq; k++) {  // frequency times add
            result.add(val);
        }
    }
}

```
---
---

10. overall bucket approch
```
class Solution {
    public int[] frequencySort(int[] nums) {
        int n = nums.length;

        // Step 1: Frequency array banana
        // Range problem me -100 to 100 hoti hai, so offset 100 use karenge
        int[] freq = new int[201];
        for (int num : nums) {
            freq[num + 100]++;
        }

        // Step 2: Buckets create karna
        // Index = frequency, Value = list of numbers with that frequency
        List<Integer>[] buckets = new List[n + 1];
        for (int i = 0; i <= n; i++) {
            buckets[i] = new ArrayList<>();
        }

        // Step 3: Fill Buckets
        for (int val = -100; val <= 100; val++) {
            int f = freq[val + 100];
            if (f > 0) {
                buckets[f].add(val);
            }
        }

        // Step 4: Sort har bucket ke andar (same frequency wale ascending order me)
        for (int i = 1; i <= n; i++) {
            if (!buckets[i].isEmpty()) {
                Collections.sort(buckets[i], Collections.reverseOrder()); 
                // reverseOrder isliye kyunki LC 1636 bolta hai:
                // "If two numbers have the same frequency, sort them by decreasing order."
            }
        }

        // Step 5: Merge buckets into final result (frequency ascending order)
        int[] res = new int[n];
        int idx = 0;
        for (int freqVal = 1; freqVal <= n; freqVal++) {
            for (int val : buckets[freqVal]) {
                for (int k = 0; k < freqVal; k++) { // frequency times add
                    res[idx++] = val;
                }
            }
        }

        return res;
    }
}

```
---

---
```
1. class Solution {
    public int[] frequencySort(int[] nums) {
        Map<Integer, Integer> freqMap = new HashMap<>();
        // Count frequency of each number
        for (int num : nums) {
            freqMap.put(num, freqMap.getOrDefault(num, 0) + 1);
        }
        // Convert array to list for sorting
        List<Integer> list = new ArrayList<>();
        for (int num : nums) {
            list.add(num);
        }
        // Sort with custom comparator
        list.sort((a, b) -> {
            int freqA = freqMap.get(a);
            int freqB = freqMap.get(b);
            if (freqA != freqB) {
                return freqA - freqB; // Increasing frequency
            } else {
                return b - a; // Decreasing value
            }
        });
        // Convert back to array
        int[] result = new int[nums.length];
        for (int i = 0; i < list.size(); i++) {
            result[i] = list.get(i);
        }
        return result;
    }

    }
```
---
---
```
2. class Solution {
    public int[] frequencySort(int[] nums) {
        int[] arr = new int[201];  // 1️⃣ Frequency array (offset by 100)
        int unique = 0;            // Unique numbers ka count

        // Step 1: Frequency count
        for (int num : nums) {
            if (arr[num + 100] == 0) unique++;  // Pehli baar aa raha hai to unique++
            arr[num + 100]++;                   // Frequency increase
        }

        int n = nums.length;
        int[] ans = new int[n];
        int pos = 0; // Output array ka pointer

        // Step 2: Repeat until all unique numbers placed
        while (unique-- > 0) {
            int bestVal = 0;                    // Is round ka best number
            int bestFreq = Integer.MAX_VALUE;   // Min frequency find karni hai

            // Step 3: Find the number with smallest frequency
            for (int i = 0; i < 201; i++) {
                if (arr[i] > 0) { // Number present hai
                    if (arr[i] < bestFreq || 
                       (arr[i] == bestFreq && (i - 100) > bestVal)) {
                        bestFreq = arr[i];      // Min frequency update
                        bestVal = i - 100;      // Actual number (offset remove)
                    }
                }
            }

            // Step 4: Place that number in output `bestFreq` times
            for (int j = 0; j < bestFreq; j++) {
                ans[pos++] = bestVal;
            }

            // Step 5: Remove this number from future consideration
            arr[bestVal + 100] = 0;
        }
        return ans;
    }
}

```
---
---
```
3. class Solution {
    public int[] frequencySort(int[] nums) {
        Map<Integer, Integer> freqMap = new HashMap<>();
        // Count frequency of each number
        for (int num : nums) {
            freqMap.put(num, freqMap.getOrDefault(num, 0) + 1);
        }
        // Convert array to list for sorting
        List<Integer> list = new ArrayList<>();
        for (int num : nums) {
            list.add(num);
        }
        // Sort with custom comparator
        list.sort((a, b) -> {
            int freqA = freqMap.get(a);
            int freqB = freqMap.get(b);
            if (freqA != freqB) {
                return freqA - freqB; // Increasing frequency
            } else {
                return b - a; // Decreasing value
            }
        });
        // Convert back to array
        int[] result = new int[nums.length];
        for (int i = 0; i < list.size(); i++) {
            result[i] = list.get(i);
        }
        return result;
    }

    }
```
---
---
```
4.
```
---
---
```
5.
```
---
---
```
6.
```
---
---
```
7.
```
---
---
```
8.
```
---

---
```
9.
```
---
---
```
10.
```
---


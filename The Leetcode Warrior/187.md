# leetcode problem 187

***good one***
---
*** *** 
---

## some important points to leran:

---
 # last case pe tle aaya but solve kar diya 
```java
class Solution {
    public List<String> findRepeatedDnaSequences(String s) {
        List<String> ans = new ArrayList<>();
        for (int i =0 ; i<=s.length()-10;i++){
            int count =0;
            String sub1 = s.substring(i, i+10); 
            String sub3 = s.substring(0, i+9); 
            if(sub3.contains(sub1)){ continue;}

            for(int j =0; j<=s.length()-10;j++){
                String sub2 = s.substring(j, j+10); 
                if(sub1.equals(sub2)){ count++;}
                  if(count>1){ ans.add(sub1); break;}
            }
        }
        return ans;
    }
}

```
---
---
 # Wrong code but count mikaln ka tarika mast h ekdam 
```java

class Solution {
    public List<String> findRepeatedDnaSequences(String s) {
        List<String> ans = new ArrayList<>();
        for (int i = 0; i <= s.length() - 10; i++) {
            String sub1 = s.substring(i, i + 10);
            String sub3 = s.substring(0, i + 9);
            if (sub3.contains(sub1)) continue;

            String result = s.replace(sub1, "");
            int count = (s.length() - result.length()) / sub1.length();

            if (count > 1) ans.add(sub1);
        }
        return ans;
    }
}

```
---
---
 # 1st accepted code 
```java
class Solution {
    public List<String> findRepeatedDnaSequences(String s) {
        HashSet<String> seen = new HashSet<>();
        HashSet<String> repeated = new HashSet<>();
        
        for (int i = 0; i <= s.length() - 10; i++) {
            String sub = s.substring(i, i + 10);
            if (!seen.add(sub)) { // agar already seen mein tha
                repeated.add(sub); // to repeated mein daalo
            }
        }
        
        return new ArrayList<>(repeated);
    }
}


```
---
---
 # Introducing new soln same logic but 80 % fast
```java

class Solution {
    public List<String> findRepeatedDnaSequences(String s) {
    
    int len = s.length();
    if (len <= 10 || len >= 10000) return new ArrayList<>();

    Set seen = new HashSet();       // stores substrings weâ€™ve already seen
    Set repeated = new HashSet();   // stores substrings that occur more than once

    for (int i = 0; i + 9 < s.length(); i++) {  // loop until last possible 10-char window
        String ten = s.substring(i, i + 10);    // extract substring of length 10
        if (!seen.add(ten))                     // if add() fails, substring was already seen
            repeated.add(ten);                  // mark as repeated
    }
    return new ArrayList(repeated);             // convert set to list
}

}
```
## why
Bahut accha sawaal hai ðŸ‘Œ. Dono code **logic-wise same** hain, lekin performance ka difference (2ms vs 15ms) chhote-chhote implementation details se aata hai. Chalo breakdown karke samjhata hoon:

---

### ðŸ”Ž 1. `if (len <= 10 || len >= 10000) return new ArrayList<>();`

* Pehle wale code mein ek **edge case check** hai: agar string bahut chhoti ya bahut badi hai, turant return kar deta hai.
* Matlab unnecessary loop hi nahi chalega (optimization).
* Dusre wale mein ye check nahi hai, to **har input pe loop chalega**, chahe result already obvious ho.

---

### ðŸ”Ž 2. **Loop condition**

* Pehle wale: `for (int i = 0; i + 9 < s.length(); i++)`
* Dusre wale: `for (int i = 0; i <= s.length() - 10; i++)`

Dono mathematically same hain, lekin compiler optimization me `i+9 < len` thoda zyada fast ho jata hai compared to `i <= len - 10` kyunki subtraction baar-baar calculate karna padta hai.

---

### ðŸ”Ž 3. **Raw types vs Generics**

* Pehle wale mein: `Set seen = new HashSet();` (raw type)

  * Yaha Java type safety check avoid kar deta hai â†’ thoda faster hoga (kyunki runtime casting check nahi hote).
* Dusre wale mein: `HashSet<String> seen = new HashSet<>();`

  * Type-safe hai, lekin JVM ko extra casting handle karni padti hai.

---

### ðŸ”Ž 4. **Return Conversion**

* Pehle wale: `return new ArrayList(repeated);`

  * Ye raw constructor hai, extra type checks nahi hote.
* Dusre wale: `return new ArrayList<>(repeated);`

  * Ye type-safe hai, lekin slightly zyada overhead.

---

### ðŸ”Ž 5. **JIT + Input Size Effect**

* Kabhi-kabhi microsecond level ka farq bhi hota hai jo LeetCode ka judge capture kar leta hai.
* Input size aur JVM ka JIT (Just-In-Time compiler) optimization bhi timings me variation create karta hai.

---

âœ… **Summary:**
Pehle wala code zyada optimized lagta hai kyunki:

1. Edge-case early return hai â†’ unnecessary loop avoid hota hai.
2. Loop condition (`i+9 < len`) compiler-friendly hai.
3. Raw types use kiye gaye hai (`Set` vs `HashSet<String>`), jisme type-checking ka overhead nahi hai.
4. ArrayList conversion bhi raw type se direct ho raha hai.



---
---
 # Another soln
```java
class Solution {
    static {
        for(int i = 0; i <= 500; i++) findRepeatedDnaSequences("Ironman");
    }

    public static List<String> findRepeatedDnaSequences(String s) {
        Set<String> seen = new HashSet<>();
        Set<String> repeated = new HashSet<>();
        for(int i = 0; i+9 < s.length(); i++){
            String ten = s.substring(i, i+10);
            if(!seen.add(ten)) repeated.add(ten);
        }
        return new ArrayList(repeated);
    }
}


```


### ðŸ”Ž Part 1: `static { ... }` block

* A **static block** in Java runs **only once** when the class is first loaded into memory.
* Inside this block:

  ```java
  for(int i = 0; i <= 500; i++) findRepeatedDnaSequences("Ironman");
  ```

  * It calls the method `findRepeatedDnaSequences("Ironman")` **501 times** (from `i = 0` to `500`).
  * But the result is **ignored**, so this loop doesnâ€™t affect anything useful here.
  * This is probably added just for **class loading warm-up or testing**. (In LeetCode-type problems, this part is unnecessary.)

---

### ðŸ”Ž Part 2: Method `findRepeatedDnaSequences(String s)`

This is the main logic.

#### Step 1: Create Sets

```java
Set<String> seen = new HashSet<>();
Set<String> repeated = new HashSet<>();
```

* `seen` â†’ stores all **unique substrings of length 10** encountered so far.
* `repeated` â†’ stores substrings that appeared **more than once**.

---

#### Step 2: Iterate through substrings of length 10

```java
for(int i = 0; i+9 < s.length(); i++){
    String ten = s.substring(i, i+10);
```

* The condition `i+9 < s.length()` ensures we donâ€™t go out of bounds.
  Example: if `s.length() = 20`, last valid `i` = `10` (substring covers `10â€¦19` â†’ length 10).
* `s.substring(i, i+10)` extracts a substring of length **10** starting at index `i`.

---

#### Step 3: Add to `seen` set

```java
if(!seen.add(ten)) repeated.add(ten);
```

* `seen.add(ten)` returns:

  * `true` if substring is added first time.
  * `false` if substring already exists.
* So:

  * If `ten` is **new**, it goes into `seen`.
  * If `ten` was already in `seen`, then it means substring appeared **again**, so we add it into `repeated`.

---

#### Step 4: Return Result

```java
return new ArrayList(repeated);
```

* Converts the `repeated` set into a `List` (because the return type is `List<String>`).
* Ensures we only return substrings that appeared **2 or more times**, no duplicates.

---

### ðŸ”Ž Example Walkthrough

Input:
`s = "AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT"`

* Substrings of length 10:

  * `"AAAAACCCCC"` (first seen, goes to `seen`)
  * `"AAAACCCCCA"` (new, goes to `seen`)
  * ...
  * `"AAAAACCCCC"` (already in `seen`, so goes into `repeated`)
  * `"CCCCCAAAAA"` (new, goes to `seen`)
  * `"CCCCAAAAAC"` (new, goes to `seen`)
  * `"CCCCCAAAAA"` (already in `seen`, so goes into `repeated`)
* Final output:
  `["AAAAACCCCC", "CCCCCAAAAA"]`

---

### âš¡ Key Points:

1. `static { ... }` block is irrelevant for solving the problem â†’ can be removed.
2. Efficient solution:

   * **O(n)** substrings checked (each length 10).
   * Using HashSet â†’ insert/check in **O(1)** average.
   * Much better than your earlier code where you used `replace()` and re-counting.


---
 #
```java


```
---
---
 #
```java


```
---
---
 #
```java


```
---
---
 #
```java


```
---
---
 #
```java


```
---
---
 #
```java


```
---
---
 #
```java


```
---
---
 #
```java


```
---
---
 #
```java


```
---
---
 #
```java


```
---
---
 #
```java


```
---
---
 #
```java


```
---
---
 #
```java


```
---
---
 #
```java


```
---
---
 #
```java


```
---
---
 #
```java


```
---
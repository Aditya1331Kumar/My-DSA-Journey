# leetcode problem 1802

***bhaut achha***
---
***The array must decrease by at most 1 per step as you move left or right from index until 1.*** 
---

## some important points to leran:

---
```
1. greedy check kon sa method hota hai 
```
---
---

2. Arrays.fill(arr, 1); ka matlab hai:
```
➡ Array arr ke har element ko 1 se set kar do.
```
---
---

3. 1 ms solution
```java
class Solution {
    public int maxValue(int n, int index, int maxSum) {
        int low = 1, high = maxSum;
        int ans = 1;

        while (low <= high) {
            int mid = low + (high - low) / 2;
            if (isPossible(n, index, maxSum, mid)) {
                ans = mid;       // valid hai, try bigger value
                low = mid + 1;
            } else {
                high = mid - 1;  // invalid hai, try smaller
            }
        }

        return ans;
    }
```
* Binary search ensures O(log maxSum) complexity.
```java
    private boolean isPossible(int n, int index, int maxSum, int peak) {
        long leftSum = calcSideSum(index, peak - 1);
        long rightSum = calcSideSum(n - index - 1, peak - 1);
        long total = leftSum + rightSum + peak;
        return total <= maxSum;
    }
```
* peak is the value at the index you want to maximize in the array.

### Left side

* length = index

* Kyunki index ke left me index elements hain

### Right side

* length = n - index - 1

* Kyunki index ke right me n-index-1 elements hain


```java
    private long calcSideSum(int length, int startVal) {
        if (startVal >= length) {
            // Pure decreasing sequence without reaching 1
            long lastVal = startVal - length + 1;
            return (long)(startVal + lastVal) * length / 2;
        } else {
            // Decrease till 1, then rest are 1's
            long seqSum = (long)(startVal + 1) * startVal / 2;
            return seqSum + (length - startVal);
        }
    }
}
```

Bilkul! Chalo **`calcSideSum`** ko **step by step aur clearly** samjhte hain. Ye function basically **array ke ek side ka sum calculate** karta hai, bina actual array banaye.

---

### **Function Code**

```java
private long calcSideSum(int length, int startVal) {
    if (startVal >= length) {
        // Case 1: Pure decreasing sequence without reaching 1
        long lastVal = startVal - length + 1;
        return (long)(startVal + lastVal) * length / 2;
    } else {
        // Case 2: Decrease till 1, then rest are 1's
        long seqSum = (long)(startVal + 1) * startVal / 2;
        return seqSum + (length - startVal);
    }
}
```



### **Step 2: Case 1 → startVal ≥ length**

* Matlab hum **decreasing sequence banate hue 1 tak nahi pahuchte**.
* Example: `startVal=5`, `length=3` → sequence = `[5,4,3]`
* Sum of arithmetic sequence formula:

$$
\text{sum} = \frac{(first + last) \cdot length}{2}
$$

* `lastVal = startVal - length + 1` → last element
* Return `(startVal + lastVal) * length / 2`



### **Step 3: Case 2 → startVal < length**

* Matlab **decreasing sequence hit 1 pe rukta hai**, aur remaining positions **fill with 1**
* Example: `startVal=2`, `length=5` → sequence = `[2,1,1,1,1]`
* Sum of decreasing part = `(startVal + 1) * startVal / 2` → sum from 1 to startVal
* Remaining positions = `length - startVal` → fill 1s
* Return `seqSum + (length - startVal)`


---
### Important: calcSideSum ko pata nahi hota left hai ya right

* Left ya right ka sum nikalna isPossible decide karta hai

* Left side ke liye → length = index

* Right side ke liye → length = n - index - 1


---
---
# Another solution
```java
class Solution {
    public int maxValue(int n, int index, int maxSum) {
        long lo=1 , hi = Integer.MAX_VALUE , result=0;
        
        while(lo<=hi){
            
            long mid= lo + (hi-lo)/2;
            
            long left=Sum(Math.min(index,mid-1),mid); //  here using 0 not 4 as number of element in left  sum will handle that negative part array will look like [0,0,0,0,1,2]. if i choose number of element is left as 4 array will look like [-3,-2,-1,0,1,2]
            left+=Math.max(0,index-mid+1);  //[1,1,1,1,1,2] to make these zeroes one
            
            long right=Sum(Math.min(n-index-1,mid-1),mid);
            right+=Math.max(0,(n-index-mid));
                
            if(left+right+mid<=maxSum){
                result=mid;  //mid is valid but not sure its the maximum answer or not . so lo=mid+1 in next step
                lo=mid+1;
            }else{
                hi=mid-1;
            }    
        }
        
        return (int)result;
    }
    
   private long Sum(long noofElement,long x){
        return x*(noofElement) - ((noofElement*(noofElement+1))/2);
    }
}
```
* Math.min(index, mid-1) → number of elements that can decrease from peak-1 on left

* Sum(...) → sum of decreasing sequence

* Math.max(0, index - mid + 1) → agar decreasing sequence se zyada elements left hain, unhe 1 assign karne ke liye
---
---
# next solution

```java
class Solution {
    public int maxValue(int n, int index, int maxSum) {
        int l = 0, r = maxSum, result = 1;
        while (l <= r) {
            int mid = l + (r - l) / 2;
            if (isValid(n, index, maxSum, mid)) {
                l = mid + 1;
                result = mid;
            } else {
                r = mid - 1;
            }
        }
        return result;
    }

    static boolean isValid(int n, int index, int maxSum, int mid) {
        long left = 0, right = 0;

        if (mid > index) {
            long first = mid - index;
            long last = mid - 1;
            left = (first + last) * index / 2;
        } else {
            long ones = index - (mid - 1);
            left = (long)mid * (mid - 1) / 2 + ones;
        }

        int rightCount = n - index - 1;
        if (mid > rightCount) {
            long first = mid - 1;
            long last = mid - rightCount;
            right = (first + last) * rightCount / 2;
        } else {
            long ones = rightCount - (mid - 1);
            right = (long)mid * (mid - 1) / 2 + ones;
        }

        return left + mid + right <= maxSum;
    }
}
```

### **4️⃣ Left side calculation**

* `index` → number of elements on left of peak

**Case 1: `mid > index`**

* Peak is big enough → left side can **decrease fully without hitting 1**
* Arithmetic sequence: `[mid-1, mid-2, ..., mid-index]`
* Sum formula: `(first + last) * length / 2`

  ```java
  first = mid - index
  last  = mid - 1
  left = (first + last) * index / 2
  ```

**Case 2: `mid <= index`**

* Peak chhota hai → decreasing sequence **1 pe ruk jaayega**, baki positions = 1
* Formula: sum of decreasing sequence + remaining ones

  ```java
  ones = index - (mid - 1)
  left = mid*(mid-1)/2 + ones
  ```

---

### **5️⃣ Right side calculation**

* `rightCount = n - index - 1` → elements on right

**Case 1: `mid > rightCount`**

* Peak bada → fully decreasing without hitting 1
* Sequence: `[mid-1, mid-2, ..., mid-rightCount]`
* Sum: `(first + last) * rightCount / 2`

**Case 2: `mid <= rightCount`**

* Sequence hits 1 → fill remaining positions with 1
* Sum: `mid*(mid-1)/2 + remaining ones`

---

### **6️⃣ Why decreasing sequence?**

* Problem rule: **peak se side jaate hue har step 1 decrease**
* Left or right me sequence **hamesha ghati hui** ho
* Minimum element = 1





---
---
```
6.
```
---
---
```
7.
```
---
---
```
8.
```
---

---
```
9.
```
---
---
```
10.
```
---

# leetcode problem 628

**khaas nhi***
---
*** *** 
---

## some important points to leran:

---
# direct 
```java
class Solution {
    public int maximumProduct(int[] nums) {
        Arrays.sort(nums);

        int n = nums.length;

        int product1 = nums[n-1] * nums[n-2] * nums[n-3];
        int product2 = nums[0] * nums[1] * nums[n-1];

        return Math.max(product1, product2);
    }
}
```
---
---
# most optimized

```java
class Solution {
    public int maximumProduct(int[] nums) {

        if (nums.length == 3) {
            return nums[0] * nums[1] * nums[2];
        }

        int max1 = Integer.MIN_VALUE;
        int max2 = Integer.MIN_VALUE;
        int max3 = Integer.MIN_VALUE;

        int min1 = Integer.MAX_VALUE;
        int min2 = Integer.MAX_VALUE;

        for (int num : nums) {


// max k liye bawe
            if (!(num <= max3)) {
                
                if (num >= max1) {
                    max3 = max2;
                    max2 = max1;
                    max1 = num;
                } else if (num >= max2) {
                    max3 = max2;
                    max2 = num;
                } else if (num >= max3) {
                    max3 = num;
                }
            }


// min k liye kar rahe h bawe
            if (!(num >= min2)) {
                
                if (num <= min1) {
                    min2 = min1;
                    min1 = num;
                } else if (num <= min2) {
                    min2 = num;
                }
            }
        }

        int sum1 = max1 * max2 * max3;
        int sum2 = min1 * min2 * max1;

        return sum1 > sum2 ? sum1 : sum2;
    }
}
```

### Reason: Maximum product candidates =

* 3 largest numbers → `max1 max2 max3`

* 2 smallest negatives + largest positive → `min1 min2 max1`
---
---

3.### gyan ki batein
* max  k liye  `Integer.MIN_VALUE`

 * min k liye `Integer.MAX_VALUE`

---
---
4. # Alag Answer
```java
class Solution {
    public int maximumProduct(int[] nums) {
        PriorityQueue<Integer> lrg = new PriorityQueue<>();
        PriorityQueue<Integer> sml = new PriorityQueue<>(Collections.reverseOrder());
        for(int x : nums) {
            if(lrg.size() >= 3) {
                if(lrg.peek() < x) {
                    lrg.poll();
                    lrg.offer(x);
                }
            } else {
                lrg.offer(x);
            }
            if(sml.size() >= 2) {
                if(sml.peek() > x) {
                    sml.poll();
                    sml.offer(x);
                }
            } else {
                sml.offer(x);
            }
        }
        int first = lrg.poll();
        int second = lrg.poll();
        int third = lrg.poll();

        return Math.max(third * second * first, third * sml.poll() * sml.poll());
    }
}
```
---
---
```
5.
```
---
---
```
6.
```
---
---
```
7.
```
---
---
```
8.
```
---

---
```
9.
```
---
---
```
10.
```
---

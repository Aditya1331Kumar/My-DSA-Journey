# leetcode problem 

***8***
---
*** *** 
---

## some important points to leran:

---
 # kuch alag soln
```java
public int numIdenticalPairs(int[] nums) {
    int[] count = new int[101]; // nums[i] ranges from 1 to 100
    int goodPairs = 0;

    for (int num : nums) {
        goodPairs += count[num]; // all previous 'num' form pairs with this 'num'
        count[num]++;            // we’ve now seen one more 'num'
    }

    return goodPairs;
}


```
---
---
 # upar wale code ko samhte hai 


1. `int[] count = new int[101];`

   * Since `nums[i] ∈ [1, 100]`, we keep a frequency array indexed by value.
   * Index `v` stores how many times we’ve seen value `v` so far.
   * Size `101` covers indices `0..100` (index `0` remains unused here).

2. `int goodPairs = 0;`

   * Accumulates the total number of good pairs.

3. `for (int num : nums) { ... }`

   * Enhanced for-loop iterates each value.

4. `goodPairs += count[num];`

   * Suppose `num = x` and we’ve already seen `x` exactly `f = count[x]` times at earlier indices.
   * The current `x` pairs with each of those `f` earlier `x` → add `f` to the answer.

5. `count[num]++;`

   * We record that we’ve now seen one more `num`.

6. `return goodPairs;`

   * After processing all elements, this is the total count.

---



# Why this works (short proof)

For any value `v` that appears `f` times total, the number of pairs among those `f` indices is:

$$
\binom{f}{2} = \frac{f(f-1)}{2} = 0 + 1 + 2 + \dots + (f-1).
$$

Your loop does exactly that **incrementally**:

* The 1st `v` adds 0,
* the 2nd adds 1,
* the 3rd adds 2,
* …,
* the `f`-th adds `f-1`.

Summing across all distinct values gives the total pairs.

---

---

# Alternatives & when to use them





   ```java
   int ans = 0;
   for (int v = 1; v <= 100; v++) {
       int f = count[v];
       ans += f * (f - 1) / 2;
   }
   ```

   Same result; your one-pass approach is a neat incremental version.


# leetcode problem 60

***8***
---
*** *** 
---

## some important points to leran:

---
 ### First (nâ€“1)! permutations start hoti hain 1 se, next (nâ€“1)! start hoti hain 2 se, and so onâ€”ye concept "blocks" ka hai.



## ğŸ§  Step 1: Question ko dekhna

> â€œGiven n and k, return the kth permutation sequence of numbers \[1..n].â€

Mere dimaag me turant do options aaye:

1. **Brute force** â†’ saare permutations generate kar lo (via recursion / backtracking), sort kar lo, fir `kth` return kar do.

   * Problem: n=9 ke liye 9! = 362,880 permutations, ye generate karna slow hai.
   * Interviews me brute force chalega nahi.

2. **Smart way** â†’ bina saare permutations generate kiye directly kth banana.

---

## ğŸ§  Step 2: Pattern samajhna

Mainne chhote cases likhe:

* n=3 ke permutations:

  ```
  123, 132, 213, 231, 312, 321
  ```

Observation:

* Total permutations = 3! = 6
* Har digit pehle position pe `(n-1)! = 2` permutations deta hai:

  * `1` ke saath â†’ \[123,132]
  * `2` ke saath â†’ \[213,231]
  * `3` ke saath â†’ \[312,321]

â†’ Matlab **blocks** ban rahe hain, har digit ke saath ek block.

---

## ğŸ§  Step 3: â€œBlock thinkingâ€

Ab socha:

* Agar mujhe kth permutation chahiye, mujhe bas yeh pata karna hai ki kth **kaunse block me aata hai**.
* Example: k=4, n=3 â†’ blocks of size 2:

  * Block 1 (1 se start) â†’ \[123,132] (positions 1â€“2)
  * Block 2 (2 se start) â†’ \[213,231] (positions 3â€“4)
  * Block 3 (3 se start) â†’ \[312,321] (positions 5â€“6)

k=4 â†’ Block 2 â†’ first digit = 2. âœ…

---

## ğŸ§  Step 4: Math formula nikalna

Block size = `(n-1)!`.
Index of block = `(k-1) / (n-1)!` (zero-based).
Isi se decide hoga kaunsa digit lena hai.

* Example: n=3, k=4
  `(4-1) / 2! = 3/2 = 1` â†’ second digit of \[1,2,3] = 2.
  Perfect!

---

## ğŸ§  Step 5: Recursion / iteration sochna

Phir dimaag me aaya: har step pe ek digit nikal lo, usko answer me daal do, baaki numbers ke liye problem chhoti ho jaati hai (n-1 size).

* Isko recursive bhi likh sakte the, par iterative likhna zyada clean tha â†’ loop from n to 1.

---

## ğŸ§  Step 6: Data structures

* Digits ko store karne ke liye ek list chahiye thi â†’ `ArrayList` best.
* Har step pe `nums.remove(index)` karna hai, isliye normal array nahi use kar sakte.

---

## ğŸ§  Step 7: Final Code Structure

1. Digits list banai `[1..n]`.
2. Factorials precompute kiye taaki bar-bar calculate na karna pade.
3. `k--` kiya (0-based sochne ke liye).
4. Loop me har position ke liye:

   * Block size nikalna (`fact[i-1]`)
   * Index = `k / blockSize`
   * Us index wala digit result me daalna
   * `k %= blockSize` update karna

Aur bas answer ready ğŸ¯

---

## ğŸ§  Real dimaag ka flow

* Problem dekha â†’ â€œsaare permutations generate karna possible nahiâ€.
* Chhote examples likhe â†’ pattern dekha.
* Pattern ko generalize karke math nikala.
* Fir data structure aur code ka form decide kiya.

---


---
---
 # the soln
```java
class Solution {
    public String getPermutation(int n, int k) {
        List<Integer> nums = new ArrayList<>();
        for (int i = 1; i <= n; i++) nums.add(i);

        int[] fact = new int[n+1];
        fact[0] = 1;
        for (int i = 1; i <= n; i++) fact[i] = fact[i-1] * i;

        k--; // zero-based index
        StringBuilder sb = new StringBuilder();

        for (int i = n; i >= 1; i--) {
            int index = k / fact[i-1];
            sb.append(nums.get(index));
            nums.remove(index);
            k %= fact[i-1];
        }
        return sb.toString();
    }
}
// ArrayList me beech se element remove karna = O(n) time (kyunki shift hota hai).


```
---
---
 # Another 
```java
private String helper(List<Integer> nums, int k, int[] fact) {
    if (nums.size() == 0) return "";
    int n = nums.size();
    int index = k / fact[n-1];
    int chosen = nums.remove(index);
    return chosen + helper(nums, k % fact[n-1], fact);
}


```
---
---
 # Another
```java

class Solution {
    public String getPermutation(int n, int k) {
        
        int[] factorial = {1, 1, 2, 6, 24, 120, 720, 5040, 40320, 362880};
        
       
        char[] digits = new char[n];
        for (int i = 0; i < n; i++) {
            digits[i] = (char)('1' + i);
        }
        
        StringBuilder result = new StringBuilder();
        k--; 
        
        for (int i = n; i > 0; i--) {
            int index = k / factorial[i - 1];
            result.append(digits[index]);
            
            
            for (int j = index; j < i - 1; j++) {
                digits[j] = digits[j + 1];
            }
            
            k %= factorial[i - 1];
        }
        
        return result.toString();
    }
}
```
---
---
 # An
```java
class Solution {
    // approach 1: thorough but slow for larger n as it generates all the permutations.
    /*
    public String getPermutation(int n, int k) {
        if (n == 1) {
            return "" + n;
        }
        int permutationsToAdd = k;
        List<String> permutations = new ArrayList<>();
        List<String> builder = new ArrayList<>();
        char[] digits = new char[n];
        for (int i = 0; i < n; i++) {
            digits[i] = (char)(i + 1 + '0');
            //System.out.println(digits[i]);
            builder.add("" + digits[i]);
        }
        // System.out.println(builder.toString());
        for (int i = 0; i < builder.size(); i++) {
            for (char digit : digits) {
                String str = builder.get(i);
                // System.out.println(str);
                // System.out.println(digit);
                if (str.indexOf(digit) == -1) {
                    String nextStr = str += digit;
                    if (nextStr.length() < n) {
                        builder.add(nextStr);
                    } else {
                        permutations.add(nextStr);
                        permutationsToAdd--;
                        if (permutationsToAdd == 0) {
                            return nextStr;
                        }
                    }
                }
            }
        }
        // System.out.println(builder.toString());
        // System.out.println(permutations.toString());
        return permutations.get(k - 1);
    }
    */

    // approach 2: directly uses k in the answer.
    public String getPermutation(int n, int k) {
        if (n == 1) {
            return "" + n;
        }
        k--; // make k use a zero-index. This really is just less of a headache afterwards.
        List<Character> remainingDigits = new ArrayList<>();
        for (int j = 1; j <= n; j++) {
            char jChar = (char) (j + '0');
            remainingDigits.add(jChar);
        }
        String output = "";
        while (!remainingDigits.isEmpty()) {
            int size = remainingDigits.size();
            if (size == 1) {
                output += remainingDigits.get(0);
                break;
            }
            int rangeWidth = factorialOf(size) / size; // 4! / 4 = 24 / 4 = 6
            int index = k / rangeWidth; // k = 8 is in the second band (2134 to 2431)
            k = k % rangeWidth; // k = 8 would have offset of 2, and should output 2314 (index 8).
            char nextChar = remainingDigits.get(index);
            System.out.println(nextChar);
            output += nextChar;
            remainingDigits.remove(Character.valueOf(nextChar));
        }
        System.out.println(remainingDigits);
        return output;
    }

    private int factorialOf(int n) {
        int nFact = 1;
        for (int i = 2; i <= n; i++) {
            nFact *= i;
        }
        return nFact;
    }
}class Solution {
    // approach 1: thorough but slow for larger n as it generates all the permutations.
    /*
    public String getPermutation(int n, int k) {
        if (n == 1) {
            return "" + n;
        }
        int permutationsToAdd = k;
        List<String> permutations = new ArrayList<>();
        List<String> builder = new ArrayList<>();
        char[] digits = new char[n];
        for (int i = 0; i < n; i++) {
            digits[i] = (char)(i + 1 + '0');
            //System.out.println(digits[i]);
            builder.add("" + digits[i]);
        }
        // System.out.println(builder.toString());
        for (int i = 0; i < builder.size(); i++) {
            for (char digit : digits) {
                String str = builder.get(i);
                // System.out.println(str);
                // System.out.println(digit);
                if (str.indexOf(digit) == -1) {
                    String nextStr = str += digit;
                    if (nextStr.length() < n) {
                        builder.add(nextStr);
                    } else {
                        permutations.add(nextStr);
                        permutationsToAdd--;
                        if (permutationsToAdd == 0) {
                            return nextStr;
                        }
                    }
                }
            }
        }
        // System.out.println(builder.toString());
        // System.out.println(permutations.toString());
        return permutations.get(k - 1);
    }
    */

    // approach 2: directly uses k in the answer.
    public String getPermutation(int n, int k) {
        if (n == 1) {
            return "" + n;
        }
        k--; // make k use a zero-index. This really is just less of a headache afterwards.
        List<Character> remainingDigits = new ArrayList<>();
        for (int j = 1; j <= n; j++) {
            char jChar = (char) (j + '0');
            remainingDigits.add(jChar);
        }
        String output = "";
        while (!remainingDigits.isEmpty()) {
            int size = remainingDigits.size();
            if (size == 1) {
                output += remainingDigits.get(0);
                break;
            }
            int rangeWidth = factorialOf(size) / size; // 4! / 4 = 24 / 4 = 6
            int index = k / rangeWidth; // k = 8 is in the second band (2134 to 2431)
            k = k % rangeWidth; // k = 8 would have offset of 2, and should output 2314 (index 8).
            char nextChar = remainingDigits.get(index);
            System.out.println(nextChar);
            output += nextChar;
            remainingDigits.remove(Character.valueOf(nextChar));
        }
        System.out.println(remainingDigits);
        return output;
    }

    private int factorialOf(int n) {
        int nFact = 1;
        for (int i = 2; i <= n; i++) {
            nFact *= i;
        }
        return nFact;
    }
}

```
---
---
 #
```java


```
---
---
 #
```java


```
---
---
 #
```java


```
---
---
 #
```java


```
---
---
 #
```java


```
---
---
 #
```java


```
---
---
 #
```java


```
---
---
 #
```java


```
---
---
 #
```java


```
---
---
 #
```java


```
---
---
 #
```java


```
---
---
 #
```java


```
---
---
 #
```java


```
---
---
 #
```java


```
---
---
 #
```java


```
---
---
 #
```java


```
---